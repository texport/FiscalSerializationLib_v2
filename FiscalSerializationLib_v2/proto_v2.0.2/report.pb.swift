// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: report.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Kkm_Proto_MoneyPlacementEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case moneyPlacementDeposit // = 0
  case moneyPlacementWithdrawal // = 1

  init() {
    self = .moneyPlacementDeposit
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .moneyPlacementDeposit
    case 1: self = .moneyPlacementWithdrawal
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .moneyPlacementDeposit: return 0
    case .moneyPlacementWithdrawal: return 1
    }
  }

}

enum Kkm_Proto_ReportTypeEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case reportZ // = 0
  case reportX // = 1

  init() {
    self = .reportZ
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .reportZ
    case 1: self = .reportX
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .reportZ: return 0
    case .reportX: return 1
    }
  }

}

struct Kkm_Proto_CloseShiftRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var closeTime: Kkm_Proto_DateTime {
    get {return _closeTime ?? Kkm_Proto_DateTime()}
    set {_closeTime = newValue}
  }
  /// Returns true if `closeTime` has been explicitly set.
  var hasCloseTime: Bool {return self._closeTime != nil}
  /// Clears the value of `closeTime`. Subsequent reads from it will return its default value.
  mutating func clearCloseTime() {self._closeTime = nil}

  var isOffline: Bool {
    get {return _isOffline ?? false}
    set {_isOffline = newValue}
  }
  /// Returns true if `isOffline` has been explicitly set.
  var hasIsOffline: Bool {return self._isOffline != nil}
  /// Clears the value of `isOffline`. Subsequent reads from it will return its default value.
  mutating func clearIsOffline() {self._isOffline = nil}

  var frShiftNumber: UInt32 {
    get {return _frShiftNumber ?? 0}
    set {_frShiftNumber = newValue}
  }
  /// Returns true if `frShiftNumber` has been explicitly set.
  var hasFrShiftNumber: Bool {return self._frShiftNumber != nil}
  /// Clears the value of `frShiftNumber`. Subsequent reads from it will return its default value.
  mutating func clearFrShiftNumber() {self._frShiftNumber = nil}

  var withdrawMoney: Bool {
    get {return _withdrawMoney ?? false}
    set {_withdrawMoney = newValue}
  }
  /// Returns true if `withdrawMoney` has been explicitly set.
  var hasWithdrawMoney: Bool {return self._withdrawMoney != nil}
  /// Clears the value of `withdrawMoney`. Subsequent reads from it will return its default value.
  mutating func clearWithdrawMoney() {self._withdrawMoney = nil}

  /// since protocol version 125 required
  var zReport: Kkm_Proto_ZXReport {
    get {return _zReport ?? Kkm_Proto_ZXReport()}
    set {_zReport = newValue}
  }
  /// Returns true if `zReport` has been explicitly set.
  var hasZReport: Bool {return self._zReport != nil}
  /// Clears the value of `zReport`. Subsequent reads from it will return its default value.
  mutating func clearZReport() {self._zReport = nil}

  /// since protocol version 125 required
  var `operator`: Kkm_Proto_Operator {
    get {return _operator ?? Kkm_Proto_Operator()}
    set {_operator = newValue}
  }
  /// Returns true if ``operator`` has been explicitly set.
  var hasOperator: Bool {return self._operator != nil}
  /// Clears the value of ``operator``. Subsequent reads from it will return its default value.
  mutating func clearOperator() {self._operator = nil}

  /// since protocol version 125
  var printedDocumentNumber: UInt64 {
    get {return _printedDocumentNumber ?? 0}
    set {_printedDocumentNumber = newValue}
  }
  /// Returns true if `printedDocumentNumber` has been explicitly set.
  var hasPrintedDocumentNumber: Bool {return self._printedDocumentNumber != nil}
  /// Clears the value of `printedDocumentNumber`. Subsequent reads from it will return its default value.
  mutating func clearPrintedDocumentNumber() {self._printedDocumentNumber = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _closeTime: Kkm_Proto_DateTime? = nil
  fileprivate var _isOffline: Bool? = nil
  fileprivate var _frShiftNumber: UInt32? = nil
  fileprivate var _withdrawMoney: Bool? = nil
  fileprivate var _zReport: Kkm_Proto_ZXReport? = nil
  fileprivate var _operator: Kkm_Proto_Operator? = nil
  fileprivate var _printedDocumentNumber: UInt64? = nil
}

struct Kkm_Proto_MoneyPlacementRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var datetime: Kkm_Proto_DateTime {
    get {return _datetime ?? Kkm_Proto_DateTime()}
    set {_datetime = newValue}
  }
  /// Returns true if `datetime` has been explicitly set.
  var hasDatetime: Bool {return self._datetime != nil}
  /// Clears the value of `datetime`. Subsequent reads from it will return its default value.
  mutating func clearDatetime() {self._datetime = nil}

  var operation: Kkm_Proto_MoneyPlacementEnum {
    get {return _operation ?? .moneyPlacementDeposit}
    set {_operation = newValue}
  }
  /// Returns true if `operation` has been explicitly set.
  var hasOperation: Bool {return self._operation != nil}
  /// Clears the value of `operation`. Subsequent reads from it will return its default value.
  mutating func clearOperation() {self._operation = nil}

  var sum: Kkm_Proto_Money {
    get {return _sum ?? Kkm_Proto_Money()}
    set {_sum = newValue}
  }
  /// Returns true if `sum` has been explicitly set.
  var hasSum: Bool {return self._sum != nil}
  /// Clears the value of `sum`. Subsequent reads from it will return its default value.
  mutating func clearSum() {self._sum = nil}

  var isOffline: Bool {
    get {return _isOffline ?? false}
    set {_isOffline = newValue}
  }
  /// Returns true if `isOffline` has been explicitly set.
  var hasIsOffline: Bool {return self._isOffline != nil}
  /// Clears the value of `isOffline`. Subsequent reads from it will return its default value.
  mutating func clearIsOffline() {self._isOffline = nil}

  var frShiftNumber: UInt32 {
    get {return _frShiftNumber ?? 0}
    set {_frShiftNumber = newValue}
  }
  /// Returns true if `frShiftNumber` has been explicitly set.
  var hasFrShiftNumber: Bool {return self._frShiftNumber != nil}
  /// Clears the value of `frShiftNumber`. Subsequent reads from it will return its default value.
  mutating func clearFrShiftNumber() {self._frShiftNumber = nil}

  /// since protocol version 125
  var printedDocumentNumber: UInt64 {
    get {return _printedDocumentNumber ?? 0}
    set {_printedDocumentNumber = newValue}
  }
  /// Returns true if `printedDocumentNumber` has been explicitly set.
  var hasPrintedDocumentNumber: Bool {return self._printedDocumentNumber != nil}
  /// Clears the value of `printedDocumentNumber`. Subsequent reads from it will return its default value.
  mutating func clearPrintedDocumentNumber() {self._printedDocumentNumber = nil}

  /// since protocol version 2.0.2, required
  var `operator`: Kkm_Proto_Operator {
    get {return _operator ?? Kkm_Proto_Operator()}
    set {_operator = newValue}
  }
  /// Returns true if ``operator`` has been explicitly set.
  var hasOperator: Bool {return self._operator != nil}
  /// Clears the value of ``operator``. Subsequent reads from it will return its default value.
  mutating func clearOperator() {self._operator = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _datetime: Kkm_Proto_DateTime? = nil
  fileprivate var _operation: Kkm_Proto_MoneyPlacementEnum? = nil
  fileprivate var _sum: Kkm_Proto_Money? = nil
  fileprivate var _isOffline: Bool? = nil
  fileprivate var _frShiftNumber: UInt32? = nil
  fileprivate var _printedDocumentNumber: UInt64? = nil
  fileprivate var _operator: Kkm_Proto_Operator? = nil
}

struct Kkm_Proto_ZXReport: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var dateTime: Kkm_Proto_DateTime {
    get {return _storage._dateTime ?? Kkm_Proto_DateTime()}
    set {_uniqueStorage()._dateTime = newValue}
  }
  /// Returns true if `dateTime` has been explicitly set.
  var hasDateTime: Bool {return _storage._dateTime != nil}
  /// Clears the value of `dateTime`. Subsequent reads from it will return its default value.
  mutating func clearDateTime() {_uniqueStorage()._dateTime = nil}

  var shiftNumber: UInt32 {
    get {return _storage._shiftNumber ?? 0}
    set {_uniqueStorage()._shiftNumber = newValue}
  }
  /// Returns true if `shiftNumber` has been explicitly set.
  var hasShiftNumber: Bool {return _storage._shiftNumber != nil}
  /// Clears the value of `shiftNumber`. Subsequent reads from it will return its default value.
  mutating func clearShiftNumber() {_uniqueStorage()._shiftNumber = nil}

  var sections: [Kkm_Proto_ZXReport.Section] {
    get {return _storage._sections}
    set {_uniqueStorage()._sections = newValue}
  }

  var operations: [Kkm_Proto_ZXReport.Operation] {
    get {return _storage._operations}
    set {_uniqueStorage()._operations = newValue}
  }

  var discounts: [Kkm_Proto_ZXReport.Operation] {
    get {return _storage._discounts}
    set {_uniqueStorage()._discounts = newValue}
  }

  var markups: [Kkm_Proto_ZXReport.Operation] {
    get {return _storage._markups}
    set {_uniqueStorage()._markups = newValue}
  }

  var totalResult: [Kkm_Proto_ZXReport.Operation] {
    get {return _storage._totalResult}
    set {_uniqueStorage()._totalResult = newValue}
  }

  var taxes: [Kkm_Proto_ZXReport.Tax] {
    get {return _storage._taxes}
    set {_uniqueStorage()._taxes = newValue}
  }

  var startShiftNonNullableSums: [Kkm_Proto_ZXReport.NonNullableSum] {
    get {return _storage._startShiftNonNullableSums}
    set {_uniqueStorage()._startShiftNonNullableSums = newValue}
  }

  var ticketOperations: [Kkm_Proto_ZXReport.TicketOperation] {
    get {return _storage._ticketOperations}
    set {_uniqueStorage()._ticketOperations = newValue}
  }

  var moneyPlacements: [Kkm_Proto_ZXReport.MoneyPlacement] {
    get {return _storage._moneyPlacements}
    set {_uniqueStorage()._moneyPlacements = newValue}
  }

  var annulledTickets: Kkm_Proto_ZXReport.AnnulledTickets {
    get {return _storage._annulledTickets ?? Kkm_Proto_ZXReport.AnnulledTickets()}
    set {_uniqueStorage()._annulledTickets = newValue}
  }
  /// Returns true if `annulledTickets` has been explicitly set.
  var hasAnnulledTickets: Bool {return _storage._annulledTickets != nil}
  /// Clears the value of `annulledTickets`. Subsequent reads from it will return its default value.
  mutating func clearAnnulledTickets() {_uniqueStorage()._annulledTickets = nil}

  var cashSum: Kkm_Proto_Money {
    get {return _storage._cashSum ?? Kkm_Proto_Money()}
    set {_uniqueStorage()._cashSum = newValue}
  }
  /// Returns true if `cashSum` has been explicitly set.
  var hasCashSum: Bool {return _storage._cashSum != nil}
  /// Clears the value of `cashSum`. Subsequent reads from it will return its default value.
  mutating func clearCashSum() {_uniqueStorage()._cashSum = nil}

  var revenue: Kkm_Proto_ZXReport.Revenue {
    get {return _storage._revenue ?? Kkm_Proto_ZXReport.Revenue()}
    set {_uniqueStorage()._revenue = newValue}
  }
  /// Returns true if `revenue` has been explicitly set.
  var hasRevenue: Bool {return _storage._revenue != nil}
  /// Clears the value of `revenue`. Subsequent reads from it will return its default value.
  mutating func clearRevenue() {_uniqueStorage()._revenue = nil}

  var nonNullableSums: [Kkm_Proto_ZXReport.NonNullableSum] {
    get {return _storage._nonNullableSums}
    set {_uniqueStorage()._nonNullableSums = newValue}
  }

  /// since protocol version 125 required
  var openShiftTime: Kkm_Proto_DateTime {
    get {return _storage._openShiftTime ?? Kkm_Proto_DateTime()}
    set {_uniqueStorage()._openShiftTime = newValue}
  }
  /// Returns true if `openShiftTime` has been explicitly set.
  var hasOpenShiftTime: Bool {return _storage._openShiftTime != nil}
  /// Clears the value of `openShiftTime`. Subsequent reads from it will return its default value.
  mutating func clearOpenShiftTime() {_uniqueStorage()._openShiftTime = nil}

  /// since protocol version 125 required
  var closeShiftTime: Kkm_Proto_DateTime {
    get {return _storage._closeShiftTime ?? Kkm_Proto_DateTime()}
    set {_uniqueStorage()._closeShiftTime = newValue}
  }
  /// Returns true if `closeShiftTime` has been explicitly set.
  var hasCloseShiftTime: Bool {return _storage._closeShiftTime != nil}
  /// Clears the value of `closeShiftTime`. Subsequent reads from it will return its default value.
  mutating func clearCloseShiftTime() {_uniqueStorage()._closeShiftTime = nil}

  /// since protocol version 125 required
  var checksum: String {
    get {return _storage._checksum ?? String()}
    set {_uniqueStorage()._checksum = newValue}
  }
  /// Returns true if `checksum` has been explicitly set.
  var hasChecksum: Bool {return _storage._checksum != nil}
  /// Clears the value of `checksum`. Subsequent reads from it will return its default value.
  mutating func clearChecksum() {_uniqueStorage()._checksum = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Operation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var operation: Kkm_Proto_OperationTypeEnum {
      get {return _operation ?? .operationBuy}
      set {_operation = newValue}
    }
    /// Returns true if `operation` has been explicitly set.
    var hasOperation: Bool {return self._operation != nil}
    /// Clears the value of `operation`. Subsequent reads from it will return its default value.
    mutating func clearOperation() {self._operation = nil}

    var count: UInt32 {
      get {return _count ?? 0}
      set {_count = newValue}
    }
    /// Returns true if `count` has been explicitly set.
    var hasCount: Bool {return self._count != nil}
    /// Clears the value of `count`. Subsequent reads from it will return its default value.
    mutating func clearCount() {self._count = nil}

    var sum: Kkm_Proto_Money {
      get {return _sum ?? Kkm_Proto_Money()}
      set {_sum = newValue}
    }
    /// Returns true if `sum` has been explicitly set.
    var hasSum: Bool {return self._sum != nil}
    /// Clears the value of `sum`. Subsequent reads from it will return its default value.
    mutating func clearSum() {self._sum = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _operation: Kkm_Proto_OperationTypeEnum? = nil
    fileprivate var _count: UInt32? = nil
    fileprivate var _sum: Kkm_Proto_Money? = nil
  }

  struct Section: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var sectionCode: String {
      get {return _sectionCode ?? String()}
      set {_sectionCode = newValue}
    }
    /// Returns true if `sectionCode` has been explicitly set.
    var hasSectionCode: Bool {return self._sectionCode != nil}
    /// Clears the value of `sectionCode`. Subsequent reads from it will return its default value.
    mutating func clearSectionCode() {self._sectionCode = nil}

    var operations: [Kkm_Proto_ZXReport.Operation] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _sectionCode: String? = nil
  }

  struct Tax: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var taxType: UInt32 {
      get {return _taxType ?? 0}
      set {_taxType = newValue}
    }
    /// Returns true if `taxType` has been explicitly set.
    var hasTaxType: Bool {return self._taxType != nil}
    /// Clears the value of `taxType`. Subsequent reads from it will return its default value.
    mutating func clearTaxType() {self._taxType = nil}

    var percent: UInt32 {
      get {return _percent ?? 0}
      set {_percent = newValue}
    }
    /// Returns true if `percent` has been explicitly set.
    var hasPercent: Bool {return self._percent != nil}
    /// Clears the value of `percent`. Subsequent reads from it will return its default value.
    mutating func clearPercent() {self._percent = nil}

    var operations: [Kkm_Proto_ZXReport.Tax.TaxOperation] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct TaxOperation: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var operation: Kkm_Proto_OperationTypeEnum {
        get {return _operation ?? .operationBuy}
        set {_operation = newValue}
      }
      /// Returns true if `operation` has been explicitly set.
      var hasOperation: Bool {return self._operation != nil}
      /// Clears the value of `operation`. Subsequent reads from it will return its default value.
      mutating func clearOperation() {self._operation = nil}

      var turnover: Kkm_Proto_Money {
        get {return _turnover ?? Kkm_Proto_Money()}
        set {_turnover = newValue}
      }
      /// Returns true if `turnover` has been explicitly set.
      var hasTurnover: Bool {return self._turnover != nil}
      /// Clears the value of `turnover`. Subsequent reads from it will return its default value.
      mutating func clearTurnover() {self._turnover = nil}

      var sum: Kkm_Proto_Money {
        get {return _sum ?? Kkm_Proto_Money()}
        set {_sum = newValue}
      }
      /// Returns true if `sum` has been explicitly set.
      var hasSum: Bool {return self._sum != nil}
      /// Clears the value of `sum`. Subsequent reads from it will return its default value.
      mutating func clearSum() {self._sum = nil}

      /// required since version 200
      var turnoverWithoutTax: Kkm_Proto_Money {
        get {return _turnoverWithoutTax ?? Kkm_Proto_Money()}
        set {_turnoverWithoutTax = newValue}
      }
      /// Returns true if `turnoverWithoutTax` has been explicitly set.
      var hasTurnoverWithoutTax: Bool {return self._turnoverWithoutTax != nil}
      /// Clears the value of `turnoverWithoutTax`. Subsequent reads from it will return its default value.
      mutating func clearTurnoverWithoutTax() {self._turnoverWithoutTax = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _operation: Kkm_Proto_OperationTypeEnum? = nil
      fileprivate var _turnover: Kkm_Proto_Money? = nil
      fileprivate var _sum: Kkm_Proto_Money? = nil
      fileprivate var _turnoverWithoutTax: Kkm_Proto_Money? = nil
    }

    init() {}

    fileprivate var _taxType: UInt32? = nil
    fileprivate var _percent: UInt32? = nil
  }

  struct NonNullableSum: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var operation: Kkm_Proto_OperationTypeEnum {
      get {return _operation ?? .operationBuy}
      set {_operation = newValue}
    }
    /// Returns true if `operation` has been explicitly set.
    var hasOperation: Bool {return self._operation != nil}
    /// Clears the value of `operation`. Subsequent reads from it will return its default value.
    mutating func clearOperation() {self._operation = nil}

    var sum: Kkm_Proto_Money {
      get {return _sum ?? Kkm_Proto_Money()}
      set {_sum = newValue}
    }
    /// Returns true if `sum` has been explicitly set.
    var hasSum: Bool {return self._sum != nil}
    /// Clears the value of `sum`. Subsequent reads from it will return its default value.
    mutating func clearSum() {self._sum = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _operation: Kkm_Proto_OperationTypeEnum? = nil
    fileprivate var _sum: Kkm_Proto_Money? = nil
  }

  struct TicketOperation: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var operation: Kkm_Proto_OperationTypeEnum {
      get {return _operation ?? .operationBuy}
      set {_operation = newValue}
    }
    /// Returns true if `operation` has been explicitly set.
    var hasOperation: Bool {return self._operation != nil}
    /// Clears the value of `operation`. Subsequent reads from it will return its default value.
    mutating func clearOperation() {self._operation = nil}

    var ticketsTotalCount: UInt32 {
      get {return _ticketsTotalCount ?? 0}
      set {_ticketsTotalCount = newValue}
    }
    /// Returns true if `ticketsTotalCount` has been explicitly set.
    var hasTicketsTotalCount: Bool {return self._ticketsTotalCount != nil}
    /// Clears the value of `ticketsTotalCount`. Subsequent reads from it will return its default value.
    mutating func clearTicketsTotalCount() {self._ticketsTotalCount = nil}

    var ticketsCount: UInt32 {
      get {return _ticketsCount ?? 0}
      set {_ticketsCount = newValue}
    }
    /// Returns true if `ticketsCount` has been explicitly set.
    var hasTicketsCount: Bool {return self._ticketsCount != nil}
    /// Clears the value of `ticketsCount`. Subsequent reads from it will return its default value.
    mutating func clearTicketsCount() {self._ticketsCount = nil}

    var ticketsSum: Kkm_Proto_Money {
      get {return _ticketsSum ?? Kkm_Proto_Money()}
      set {_ticketsSum = newValue}
    }
    /// Returns true if `ticketsSum` has been explicitly set.
    var hasTicketsSum: Bool {return self._ticketsSum != nil}
    /// Clears the value of `ticketsSum`. Subsequent reads from it will return its default value.
    mutating func clearTicketsSum() {self._ticketsSum = nil}

    var payments: [Kkm_Proto_ZXReport.TicketOperation.Payment] = []

    /// since protocol version 125 required
    var offlineCount: UInt32 {
      get {return _offlineCount ?? 0}
      set {_offlineCount = newValue}
    }
    /// Returns true if `offlineCount` has been explicitly set.
    var hasOfflineCount: Bool {return self._offlineCount != nil}
    /// Clears the value of `offlineCount`. Subsequent reads from it will return its default value.
    mutating func clearOfflineCount() {self._offlineCount = nil}

    /// since protocol version 125 required
    var discountSum: Kkm_Proto_Money {
      get {return _discountSum ?? Kkm_Proto_Money()}
      set {_discountSum = newValue}
    }
    /// Returns true if `discountSum` has been explicitly set.
    var hasDiscountSum: Bool {return self._discountSum != nil}
    /// Clears the value of `discountSum`. Subsequent reads from it will return its default value.
    mutating func clearDiscountSum() {self._discountSum = nil}

    /// since protocol version 125 required
    var markupSum: Kkm_Proto_Money {
      get {return _markupSum ?? Kkm_Proto_Money()}
      set {_markupSum = newValue}
    }
    /// Returns true if `markupSum` has been explicitly set.
    var hasMarkupSum: Bool {return self._markupSum != nil}
    /// Clears the value of `markupSum`. Subsequent reads from it will return its default value.
    mutating func clearMarkupSum() {self._markupSum = nil}

    /// since protocol version 125 required
    var changeSum: Kkm_Proto_Money {
      get {return _changeSum ?? Kkm_Proto_Money()}
      set {_changeSum = newValue}
    }
    /// Returns true if `changeSum` has been explicitly set.
    var hasChangeSum: Bool {return self._changeSum != nil}
    /// Clears the value of `changeSum`. Subsequent reads from it will return its default value.
    mutating func clearChangeSum() {self._changeSum = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    struct Payment: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var payment: Kkm_Proto_PaymentTypeEnum {
        get {return _payment ?? .paymentCash}
        set {_payment = newValue}
      }
      /// Returns true if `payment` has been explicitly set.
      var hasPayment: Bool {return self._payment != nil}
      /// Clears the value of `payment`. Subsequent reads from it will return its default value.
      mutating func clearPayment() {self._payment = nil}

      var sum: Kkm_Proto_Money {
        get {return _sum ?? Kkm_Proto_Money()}
        set {_sum = newValue}
      }
      /// Returns true if `sum` has been explicitly set.
      var hasSum: Bool {return self._sum != nil}
      /// Clears the value of `sum`. Subsequent reads from it will return its default value.
      mutating func clearSum() {self._sum = nil}

      /// since protocol version 125 required
      var count: UInt32 {
        get {return _count ?? 0}
        set {_count = newValue}
      }
      /// Returns true if `count` has been explicitly set.
      var hasCount: Bool {return self._count != nil}
      /// Clears the value of `count`. Subsequent reads from it will return its default value.
      mutating func clearCount() {self._count = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _payment: Kkm_Proto_PaymentTypeEnum? = nil
      fileprivate var _sum: Kkm_Proto_Money? = nil
      fileprivate var _count: UInt32? = nil
    }

    init() {}

    fileprivate var _operation: Kkm_Proto_OperationTypeEnum? = nil
    fileprivate var _ticketsTotalCount: UInt32? = nil
    fileprivate var _ticketsCount: UInt32? = nil
    fileprivate var _ticketsSum: Kkm_Proto_Money? = nil
    fileprivate var _offlineCount: UInt32? = nil
    fileprivate var _discountSum: Kkm_Proto_Money? = nil
    fileprivate var _markupSum: Kkm_Proto_Money? = nil
    fileprivate var _changeSum: Kkm_Proto_Money? = nil
  }

  struct MoneyPlacement: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var operation: Kkm_Proto_MoneyPlacementEnum {
      get {return _operation ?? .moneyPlacementDeposit}
      set {_operation = newValue}
    }
    /// Returns true if `operation` has been explicitly set.
    var hasOperation: Bool {return self._operation != nil}
    /// Clears the value of `operation`. Subsequent reads from it will return its default value.
    mutating func clearOperation() {self._operation = nil}

    var operationsTotalCount: UInt32 {
      get {return _operationsTotalCount ?? 0}
      set {_operationsTotalCount = newValue}
    }
    /// Returns true if `operationsTotalCount` has been explicitly set.
    var hasOperationsTotalCount: Bool {return self._operationsTotalCount != nil}
    /// Clears the value of `operationsTotalCount`. Subsequent reads from it will return its default value.
    mutating func clearOperationsTotalCount() {self._operationsTotalCount = nil}

    var operationsCount: UInt32 {
      get {return _operationsCount ?? 0}
      set {_operationsCount = newValue}
    }
    /// Returns true if `operationsCount` has been explicitly set.
    var hasOperationsCount: Bool {return self._operationsCount != nil}
    /// Clears the value of `operationsCount`. Subsequent reads from it will return its default value.
    mutating func clearOperationsCount() {self._operationsCount = nil}

    var operationsSum: Kkm_Proto_Money {
      get {return _operationsSum ?? Kkm_Proto_Money()}
      set {_operationsSum = newValue}
    }
    /// Returns true if `operationsSum` has been explicitly set.
    var hasOperationsSum: Bool {return self._operationsSum != nil}
    /// Clears the value of `operationsSum`. Subsequent reads from it will return its default value.
    mutating func clearOperationsSum() {self._operationsSum = nil}

    /// since protocol version 125 required
    var offlineCount: UInt32 {
      get {return _offlineCount ?? 0}
      set {_offlineCount = newValue}
    }
    /// Returns true if `offlineCount` has been explicitly set.
    var hasOfflineCount: Bool {return self._offlineCount != nil}
    /// Clears the value of `offlineCount`. Subsequent reads from it will return its default value.
    mutating func clearOfflineCount() {self._offlineCount = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _operation: Kkm_Proto_MoneyPlacementEnum? = nil
    fileprivate var _operationsTotalCount: UInt32? = nil
    fileprivate var _operationsCount: UInt32? = nil
    fileprivate var _operationsSum: Kkm_Proto_Money? = nil
    fileprivate var _offlineCount: UInt32? = nil
  }

  struct AnnulledTickets: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var annulledTicketsTotalCount: UInt32 {
      get {return _annulledTicketsTotalCount ?? 0}
      set {_annulledTicketsTotalCount = newValue}
    }
    /// Returns true if `annulledTicketsTotalCount` has been explicitly set.
    var hasAnnulledTicketsTotalCount: Bool {return self._annulledTicketsTotalCount != nil}
    /// Clears the value of `annulledTicketsTotalCount`. Subsequent reads from it will return its default value.
    mutating func clearAnnulledTicketsTotalCount() {self._annulledTicketsTotalCount = nil}

    var annulledTicketsCount: UInt32 {
      get {return _annulledTicketsCount ?? 0}
      set {_annulledTicketsCount = newValue}
    }
    /// Returns true if `annulledTicketsCount` has been explicitly set.
    var hasAnnulledTicketsCount: Bool {return self._annulledTicketsCount != nil}
    /// Clears the value of `annulledTicketsCount`. Subsequent reads from it will return its default value.
    mutating func clearAnnulledTicketsCount() {self._annulledTicketsCount = nil}

    var annulledOperations: [Kkm_Proto_ZXReport.Operation] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _annulledTicketsTotalCount: UInt32? = nil
    fileprivate var _annulledTicketsCount: UInt32? = nil
  }

  struct Revenue: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var sum: Kkm_Proto_Money {
      get {return _sum ?? Kkm_Proto_Money()}
      set {_sum = newValue}
    }
    /// Returns true if `sum` has been explicitly set.
    var hasSum: Bool {return self._sum != nil}
    /// Clears the value of `sum`. Subsequent reads from it will return its default value.
    mutating func clearSum() {self._sum = nil}

    var isNegative: Bool {
      get {return _isNegative ?? false}
      set {_isNegative = newValue}
    }
    /// Returns true if `isNegative` has been explicitly set.
    var hasIsNegative: Bool {return self._isNegative != nil}
    /// Clears the value of `isNegative`. Subsequent reads from it will return its default value.
    mutating func clearIsNegative() {self._isNegative = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _sum: Kkm_Proto_Money? = nil
    fileprivate var _isNegative: Bool? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Kkm_Proto_ReportRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var report: Kkm_Proto_ReportTypeEnum {
    get {return _report ?? .reportZ}
    set {_report = newValue}
  }
  /// Returns true if `report` has been explicitly set.
  var hasReport: Bool {return self._report != nil}
  /// Clears the value of `report`. Subsequent reads from it will return its default value.
  mutating func clearReport() {self._report = nil}

  var dateTime: Kkm_Proto_DateTime {
    get {return _dateTime ?? Kkm_Proto_DateTime()}
    set {_dateTime = newValue}
  }
  /// Returns true if `dateTime` has been explicitly set.
  var hasDateTime: Bool {return self._dateTime != nil}
  /// Clears the value of `dateTime`. Subsequent reads from it will return its default value.
  mutating func clearDateTime() {self._dateTime = nil}

  var isOffline: Bool {
    get {return _isOffline ?? false}
    set {_isOffline = newValue}
  }
  /// Returns true if `isOffline` has been explicitly set.
  var hasIsOffline: Bool {return self._isOffline != nil}
  /// Clears the value of `isOffline`. Subsequent reads from it will return its default value.
  mutating func clearIsOffline() {self._isOffline = nil}

  /// since protocol version 125 required
  var zxReport: Kkm_Proto_ZXReport {
    get {return _zxReport ?? Kkm_Proto_ZXReport()}
    set {_zxReport = newValue}
  }
  /// Returns true if `zxReport` has been explicitly set.
  var hasZxReport: Bool {return self._zxReport != nil}
  /// Clears the value of `zxReport`. Subsequent reads from it will return its default value.
  mutating func clearZxReport() {self._zxReport = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _report: Kkm_Proto_ReportTypeEnum? = nil
  fileprivate var _dateTime: Kkm_Proto_DateTime? = nil
  fileprivate var _isOffline: Bool? = nil
  fileprivate var _zxReport: Kkm_Proto_ZXReport? = nil
}

struct Kkm_Proto_ReportResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var report: Kkm_Proto_ReportTypeEnum {
    get {return _report ?? .reportZ}
    set {_report = newValue}
  }
  /// Returns true if `report` has been explicitly set.
  var hasReport: Bool {return self._report != nil}
  /// Clears the value of `report`. Subsequent reads from it will return its default value.
  mutating func clearReport() {self._report = nil}

  var zxReport: Kkm_Proto_ZXReport {
    get {return _zxReport ?? Kkm_Proto_ZXReport()}
    set {_zxReport = newValue}
  }
  /// Returns true if `zxReport` has been explicitly set.
  var hasZxReport: Bool {return self._zxReport != nil}
  /// Clears the value of `zxReport`. Subsequent reads from it will return its default value.
  mutating func clearZxReport() {self._zxReport = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _report: Kkm_Proto_ReportTypeEnum? = nil
  fileprivate var _zxReport: Kkm_Proto_ZXReport? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "kkm.proto"

extension Kkm_Proto_MoneyPlacementEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "MONEY_PLACEMENT_DEPOSIT"),
    1: .same(proto: "MONEY_PLACEMENT_WITHDRAWAL"),
  ]
}

extension Kkm_Proto_ReportTypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "REPORT_Z"),
    1: .same(proto: "REPORT_X"),
  ]
}

extension Kkm_Proto_CloseShiftRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CloseShiftRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "close_time"),
    2: .standard(proto: "is_offline"),
    3: .standard(proto: "fr_shift_number"),
    4: .standard(proto: "withdraw_money"),
    5: .standard(proto: "z_report"),
    6: .same(proto: "operator"),
    7: .standard(proto: "printed_document_number"),
  ]

  public var isInitialized: Bool {
    if self._closeTime == nil {return false}
    if let v = self._closeTime, !v.isInitialized {return false}
    if let v = self._zReport, !v.isInitialized {return false}
    if let v = self._operator, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._closeTime) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._isOffline) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._frShiftNumber) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._withdrawMoney) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._zReport) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._operator) }()
      case 7: try { try decoder.decodeSingularUInt64Field(value: &self._printedDocumentNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._closeTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._isOffline {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._frShiftNumber {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._withdrawMoney {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._zReport {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._operator {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._printedDocumentNumber {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kkm_Proto_CloseShiftRequest, rhs: Kkm_Proto_CloseShiftRequest) -> Bool {
    if lhs._closeTime != rhs._closeTime {return false}
    if lhs._isOffline != rhs._isOffline {return false}
    if lhs._frShiftNumber != rhs._frShiftNumber {return false}
    if lhs._withdrawMoney != rhs._withdrawMoney {return false}
    if lhs._zReport != rhs._zReport {return false}
    if lhs._operator != rhs._operator {return false}
    if lhs._printedDocumentNumber != rhs._printedDocumentNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kkm_Proto_MoneyPlacementRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MoneyPlacementRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "datetime"),
    2: .same(proto: "operation"),
    3: .same(proto: "sum"),
    4: .standard(proto: "is_offline"),
    5: .standard(proto: "fr_shift_number"),
    6: .standard(proto: "printed_document_number"),
    7: .same(proto: "operator"),
  ]

  public var isInitialized: Bool {
    if self._datetime == nil {return false}
    if self._operation == nil {return false}
    if self._sum == nil {return false}
    if let v = self._datetime, !v.isInitialized {return false}
    if let v = self._sum, !v.isInitialized {return false}
    if let v = self._operator, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._datetime) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self._operation) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._sum) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self._isOffline) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._frShiftNumber) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self._printedDocumentNumber) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._operator) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._datetime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._operation {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._sum {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._isOffline {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._frShiftNumber {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._printedDocumentNumber {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._operator {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kkm_Proto_MoneyPlacementRequest, rhs: Kkm_Proto_MoneyPlacementRequest) -> Bool {
    if lhs._datetime != rhs._datetime {return false}
    if lhs._operation != rhs._operation {return false}
    if lhs._sum != rhs._sum {return false}
    if lhs._isOffline != rhs._isOffline {return false}
    if lhs._frShiftNumber != rhs._frShiftNumber {return false}
    if lhs._printedDocumentNumber != rhs._printedDocumentNumber {return false}
    if lhs._operator != rhs._operator {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kkm_Proto_ZXReport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ZXReport"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "date_time"),
    2: .standard(proto: "shift_number"),
    3: .same(proto: "sections"),
    4: .same(proto: "operations"),
    5: .same(proto: "discounts"),
    6: .same(proto: "markups"),
    7: .standard(proto: "total_result"),
    8: .same(proto: "taxes"),
    9: .standard(proto: "start_shift_non_nullable_sums"),
    10: .standard(proto: "ticket_operations"),
    11: .standard(proto: "money_placements"),
    12: .standard(proto: "annulled_tickets"),
    13: .standard(proto: "cash_sum"),
    14: .same(proto: "revenue"),
    15: .standard(proto: "non_nullable_sums"),
    16: .standard(proto: "open_shift_time"),
    17: .standard(proto: "close_shift_time"),
    18: .same(proto: "checksum"),
  ]

  fileprivate class _StorageClass {
    var _dateTime: Kkm_Proto_DateTime? = nil
    var _shiftNumber: UInt32? = nil
    var _sections: [Kkm_Proto_ZXReport.Section] = []
    var _operations: [Kkm_Proto_ZXReport.Operation] = []
    var _discounts: [Kkm_Proto_ZXReport.Operation] = []
    var _markups: [Kkm_Proto_ZXReport.Operation] = []
    var _totalResult: [Kkm_Proto_ZXReport.Operation] = []
    var _taxes: [Kkm_Proto_ZXReport.Tax] = []
    var _startShiftNonNullableSums: [Kkm_Proto_ZXReport.NonNullableSum] = []
    var _ticketOperations: [Kkm_Proto_ZXReport.TicketOperation] = []
    var _moneyPlacements: [Kkm_Proto_ZXReport.MoneyPlacement] = []
    var _annulledTickets: Kkm_Proto_ZXReport.AnnulledTickets? = nil
    var _cashSum: Kkm_Proto_Money? = nil
    var _revenue: Kkm_Proto_ZXReport.Revenue? = nil
    var _nonNullableSums: [Kkm_Proto_ZXReport.NonNullableSum] = []
    var _openShiftTime: Kkm_Proto_DateTime? = nil
    var _closeShiftTime: Kkm_Proto_DateTime? = nil
    var _checksum: String? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _dateTime = source._dateTime
      _shiftNumber = source._shiftNumber
      _sections = source._sections
      _operations = source._operations
      _discounts = source._discounts
      _markups = source._markups
      _totalResult = source._totalResult
      _taxes = source._taxes
      _startShiftNonNullableSums = source._startShiftNonNullableSums
      _ticketOperations = source._ticketOperations
      _moneyPlacements = source._moneyPlacements
      _annulledTickets = source._annulledTickets
      _cashSum = source._cashSum
      _revenue = source._revenue
      _nonNullableSums = source._nonNullableSums
      _openShiftTime = source._openShiftTime
      _closeShiftTime = source._closeShiftTime
      _checksum = source._checksum
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._dateTime == nil {return false}
      if _storage._shiftNumber == nil {return false}
      if _storage._cashSum == nil {return false}
      if _storage._revenue == nil {return false}
      if let v = _storage._dateTime, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._sections) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._operations) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._discounts) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._markups) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._totalResult) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._taxes) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._startShiftNonNullableSums) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._ticketOperations) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._moneyPlacements) {return false}
      if let v = _storage._annulledTickets, !v.isInitialized {return false}
      if let v = _storage._cashSum, !v.isInitialized {return false}
      if let v = _storage._revenue, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._nonNullableSums) {return false}
      if let v = _storage._openShiftTime, !v.isInitialized {return false}
      if let v = _storage._closeShiftTime, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._dateTime) }()
        case 2: try { try decoder.decodeSingularUInt32Field(value: &_storage._shiftNumber) }()
        case 3: try { try decoder.decodeRepeatedMessageField(value: &_storage._sections) }()
        case 4: try { try decoder.decodeRepeatedMessageField(value: &_storage._operations) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._discounts) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._markups) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._totalResult) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._taxes) }()
        case 9: try { try decoder.decodeRepeatedMessageField(value: &_storage._startShiftNonNullableSums) }()
        case 10: try { try decoder.decodeRepeatedMessageField(value: &_storage._ticketOperations) }()
        case 11: try { try decoder.decodeRepeatedMessageField(value: &_storage._moneyPlacements) }()
        case 12: try { try decoder.decodeSingularMessageField(value: &_storage._annulledTickets) }()
        case 13: try { try decoder.decodeSingularMessageField(value: &_storage._cashSum) }()
        case 14: try { try decoder.decodeSingularMessageField(value: &_storage._revenue) }()
        case 15: try { try decoder.decodeRepeatedMessageField(value: &_storage._nonNullableSums) }()
        case 16: try { try decoder.decodeSingularMessageField(value: &_storage._openShiftTime) }()
        case 17: try { try decoder.decodeSingularMessageField(value: &_storage._closeShiftTime) }()
        case 18: try { try decoder.decodeSingularStringField(value: &_storage._checksum) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._dateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._shiftNumber {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
      } }()
      if !_storage._sections.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._sections, fieldNumber: 3)
      }
      if !_storage._operations.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._operations, fieldNumber: 4)
      }
      if !_storage._discounts.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._discounts, fieldNumber: 5)
      }
      if !_storage._markups.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._markups, fieldNumber: 6)
      }
      if !_storage._totalResult.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._totalResult, fieldNumber: 7)
      }
      if !_storage._taxes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._taxes, fieldNumber: 8)
      }
      if !_storage._startShiftNonNullableSums.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._startShiftNonNullableSums, fieldNumber: 9)
      }
      if !_storage._ticketOperations.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._ticketOperations, fieldNumber: 10)
      }
      if !_storage._moneyPlacements.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._moneyPlacements, fieldNumber: 11)
      }
      try { if let v = _storage._annulledTickets {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 12)
      } }()
      try { if let v = _storage._cashSum {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 13)
      } }()
      try { if let v = _storage._revenue {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 14)
      } }()
      if !_storage._nonNullableSums.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._nonNullableSums, fieldNumber: 15)
      }
      try { if let v = _storage._openShiftTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 16)
      } }()
      try { if let v = _storage._closeShiftTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 17)
      } }()
      try { if let v = _storage._checksum {
        try visitor.visitSingularStringField(value: v, fieldNumber: 18)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kkm_Proto_ZXReport, rhs: Kkm_Proto_ZXReport) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._dateTime != rhs_storage._dateTime {return false}
        if _storage._shiftNumber != rhs_storage._shiftNumber {return false}
        if _storage._sections != rhs_storage._sections {return false}
        if _storage._operations != rhs_storage._operations {return false}
        if _storage._discounts != rhs_storage._discounts {return false}
        if _storage._markups != rhs_storage._markups {return false}
        if _storage._totalResult != rhs_storage._totalResult {return false}
        if _storage._taxes != rhs_storage._taxes {return false}
        if _storage._startShiftNonNullableSums != rhs_storage._startShiftNonNullableSums {return false}
        if _storage._ticketOperations != rhs_storage._ticketOperations {return false}
        if _storage._moneyPlacements != rhs_storage._moneyPlacements {return false}
        if _storage._annulledTickets != rhs_storage._annulledTickets {return false}
        if _storage._cashSum != rhs_storage._cashSum {return false}
        if _storage._revenue != rhs_storage._revenue {return false}
        if _storage._nonNullableSums != rhs_storage._nonNullableSums {return false}
        if _storage._openShiftTime != rhs_storage._openShiftTime {return false}
        if _storage._closeShiftTime != rhs_storage._closeShiftTime {return false}
        if _storage._checksum != rhs_storage._checksum {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kkm_Proto_ZXReport.Operation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Kkm_Proto_ZXReport.protoMessageName + ".Operation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operation"),
    2: .same(proto: "count"),
    3: .same(proto: "sum"),
  ]

  public var isInitialized: Bool {
    if self._operation == nil {return false}
    if self._count == nil {return false}
    if self._sum == nil {return false}
    if let v = self._sum, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._operation) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._count) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._sum) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._operation {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._count {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._sum {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kkm_Proto_ZXReport.Operation, rhs: Kkm_Proto_ZXReport.Operation) -> Bool {
    if lhs._operation != rhs._operation {return false}
    if lhs._count != rhs._count {return false}
    if lhs._sum != rhs._sum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kkm_Proto_ZXReport.Section: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Kkm_Proto_ZXReport.protoMessageName + ".Section"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "section_code"),
    2: .same(proto: "operations"),
  ]

  public var isInitialized: Bool {
    if self._sectionCode == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.operations) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._sectionCode) }()
      case 2: try { try decoder.decodeRepeatedMessageField(value: &self.operations) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sectionCode {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    if !self.operations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.operations, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kkm_Proto_ZXReport.Section, rhs: Kkm_Proto_ZXReport.Section) -> Bool {
    if lhs._sectionCode != rhs._sectionCode {return false}
    if lhs.operations != rhs.operations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kkm_Proto_ZXReport.Tax: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Kkm_Proto_ZXReport.protoMessageName + ".Tax"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tax_type"),
    2: .same(proto: "percent"),
    3: .same(proto: "operations"),
  ]

  public var isInitialized: Bool {
    if self._taxType == nil {return false}
    if self._percent == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.operations) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._taxType) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._percent) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.operations) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._taxType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._percent {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    if !self.operations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.operations, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kkm_Proto_ZXReport.Tax, rhs: Kkm_Proto_ZXReport.Tax) -> Bool {
    if lhs._taxType != rhs._taxType {return false}
    if lhs._percent != rhs._percent {return false}
    if lhs.operations != rhs.operations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kkm_Proto_ZXReport.Tax.TaxOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Kkm_Proto_ZXReport.Tax.protoMessageName + ".TaxOperation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operation"),
    2: .same(proto: "turnover"),
    3: .same(proto: "sum"),
    4: .standard(proto: "turnover_without_tax"),
  ]

  public var isInitialized: Bool {
    if self._operation == nil {return false}
    if self._turnover == nil {return false}
    if self._sum == nil {return false}
    if let v = self._turnover, !v.isInitialized {return false}
    if let v = self._sum, !v.isInitialized {return false}
    if let v = self._turnoverWithoutTax, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._operation) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._turnover) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._sum) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._turnoverWithoutTax) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._operation {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._turnover {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._sum {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._turnoverWithoutTax {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kkm_Proto_ZXReport.Tax.TaxOperation, rhs: Kkm_Proto_ZXReport.Tax.TaxOperation) -> Bool {
    if lhs._operation != rhs._operation {return false}
    if lhs._turnover != rhs._turnover {return false}
    if lhs._sum != rhs._sum {return false}
    if lhs._turnoverWithoutTax != rhs._turnoverWithoutTax {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kkm_Proto_ZXReport.NonNullableSum: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Kkm_Proto_ZXReport.protoMessageName + ".NonNullableSum"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operation"),
    2: .same(proto: "sum"),
  ]

  public var isInitialized: Bool {
    if self._operation == nil {return false}
    if self._sum == nil {return false}
    if let v = self._sum, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._operation) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sum) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._operation {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sum {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kkm_Proto_ZXReport.NonNullableSum, rhs: Kkm_Proto_ZXReport.NonNullableSum) -> Bool {
    if lhs._operation != rhs._operation {return false}
    if lhs._sum != rhs._sum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kkm_Proto_ZXReport.TicketOperation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Kkm_Proto_ZXReport.protoMessageName + ".TicketOperation"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operation"),
    2: .standard(proto: "tickets_total_count"),
    3: .standard(proto: "tickets_count"),
    4: .standard(proto: "tickets_sum"),
    5: .same(proto: "payments"),
    6: .standard(proto: "offline_count"),
    7: .standard(proto: "discount_sum"),
    8: .standard(proto: "markup_sum"),
    9: .standard(proto: "change_sum"),
  ]

  public var isInitialized: Bool {
    if self._operation == nil {return false}
    if self._ticketsTotalCount == nil {return false}
    if self._ticketsCount == nil {return false}
    if self._ticketsSum == nil {return false}
    if let v = self._ticketsSum, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.payments) {return false}
    if let v = self._discountSum, !v.isInitialized {return false}
    if let v = self._markupSum, !v.isInitialized {return false}
    if let v = self._changeSum, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._operation) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._ticketsTotalCount) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._ticketsCount) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._ticketsSum) }()
      case 5: try { try decoder.decodeRepeatedMessageField(value: &self.payments) }()
      case 6: try { try decoder.decodeSingularUInt32Field(value: &self._offlineCount) }()
      case 7: try { try decoder.decodeSingularMessageField(value: &self._discountSum) }()
      case 8: try { try decoder.decodeSingularMessageField(value: &self._markupSum) }()
      case 9: try { try decoder.decodeSingularMessageField(value: &self._changeSum) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._operation {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._ticketsTotalCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._ticketsCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._ticketsSum {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    if !self.payments.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.payments, fieldNumber: 5)
    }
    try { if let v = self._offlineCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 6)
    } }()
    try { if let v = self._discountSum {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
    } }()
    try { if let v = self._markupSum {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
    } }()
    try { if let v = self._changeSum {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kkm_Proto_ZXReport.TicketOperation, rhs: Kkm_Proto_ZXReport.TicketOperation) -> Bool {
    if lhs._operation != rhs._operation {return false}
    if lhs._ticketsTotalCount != rhs._ticketsTotalCount {return false}
    if lhs._ticketsCount != rhs._ticketsCount {return false}
    if lhs._ticketsSum != rhs._ticketsSum {return false}
    if lhs.payments != rhs.payments {return false}
    if lhs._offlineCount != rhs._offlineCount {return false}
    if lhs._discountSum != rhs._discountSum {return false}
    if lhs._markupSum != rhs._markupSum {return false}
    if lhs._changeSum != rhs._changeSum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kkm_Proto_ZXReport.TicketOperation.Payment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Kkm_Proto_ZXReport.TicketOperation.protoMessageName + ".Payment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "payment"),
    2: .same(proto: "sum"),
    3: .same(proto: "count"),
  ]

  public var isInitialized: Bool {
    if self._payment == nil {return false}
    if self._sum == nil {return false}
    if let v = self._sum, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._payment) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sum) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._count) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._payment {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sum {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._count {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kkm_Proto_ZXReport.TicketOperation.Payment, rhs: Kkm_Proto_ZXReport.TicketOperation.Payment) -> Bool {
    if lhs._payment != rhs._payment {return false}
    if lhs._sum != rhs._sum {return false}
    if lhs._count != rhs._count {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kkm_Proto_ZXReport.MoneyPlacement: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Kkm_Proto_ZXReport.protoMessageName + ".MoneyPlacement"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operation"),
    2: .standard(proto: "operations_total_count"),
    3: .standard(proto: "operations_count"),
    4: .standard(proto: "operations_sum"),
    5: .standard(proto: "offline_count"),
  ]

  public var isInitialized: Bool {
    if self._operation == nil {return false}
    if self._operationsTotalCount == nil {return false}
    if self._operationsCount == nil {return false}
    if self._operationsSum == nil {return false}
    if let v = self._operationsSum, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._operation) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._operationsTotalCount) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._operationsCount) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._operationsSum) }()
      case 5: try { try decoder.decodeSingularUInt32Field(value: &self._offlineCount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._operation {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._operationsTotalCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._operationsCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._operationsSum {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._offlineCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kkm_Proto_ZXReport.MoneyPlacement, rhs: Kkm_Proto_ZXReport.MoneyPlacement) -> Bool {
    if lhs._operation != rhs._operation {return false}
    if lhs._operationsTotalCount != rhs._operationsTotalCount {return false}
    if lhs._operationsCount != rhs._operationsCount {return false}
    if lhs._operationsSum != rhs._operationsSum {return false}
    if lhs._offlineCount != rhs._offlineCount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kkm_Proto_ZXReport.AnnulledTickets: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Kkm_Proto_ZXReport.protoMessageName + ".AnnulledTickets"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "annulled_tickets_total_count"),
    2: .standard(proto: "annulled_tickets_count"),
    3: .standard(proto: "annulled_operations"),
  ]

  public var isInitialized: Bool {
    if self._annulledTicketsTotalCount == nil {return false}
    if self._annulledTicketsCount == nil {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.annulledOperations) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._annulledTicketsTotalCount) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._annulledTicketsCount) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.annulledOperations) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._annulledTicketsTotalCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._annulledTicketsCount {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    if !self.annulledOperations.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.annulledOperations, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kkm_Proto_ZXReport.AnnulledTickets, rhs: Kkm_Proto_ZXReport.AnnulledTickets) -> Bool {
    if lhs._annulledTicketsTotalCount != rhs._annulledTicketsTotalCount {return false}
    if lhs._annulledTicketsCount != rhs._annulledTicketsCount {return false}
    if lhs.annulledOperations != rhs.annulledOperations {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kkm_Proto_ZXReport.Revenue: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Kkm_Proto_ZXReport.protoMessageName + ".Revenue"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "sum"),
    2: .standard(proto: "is_negative"),
  ]

  public var isInitialized: Bool {
    if self._sum == nil {return false}
    if self._isNegative == nil {return false}
    if let v = self._sum, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._sum) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._isNegative) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._sum {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._isNegative {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kkm_Proto_ZXReport.Revenue, rhs: Kkm_Proto_ZXReport.Revenue) -> Bool {
    if lhs._sum != rhs._sum {return false}
    if lhs._isNegative != rhs._isNegative {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kkm_Proto_ReportRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReportRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "report"),
    2: .standard(proto: "date_time"),
    3: .standard(proto: "is_offline"),
    4: .standard(proto: "zx_report"),
  ]

  public var isInitialized: Bool {
    if self._report == nil {return false}
    if self._dateTime == nil {return false}
    if let v = self._dateTime, !v.isInitialized {return false}
    if let v = self._zxReport, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._report) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._dateTime) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self._isOffline) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._zxReport) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._report {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._dateTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._isOffline {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._zxReport {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kkm_Proto_ReportRequest, rhs: Kkm_Proto_ReportRequest) -> Bool {
    if lhs._report != rhs._report {return false}
    if lhs._dateTime != rhs._dateTime {return false}
    if lhs._isOffline != rhs._isOffline {return false}
    if lhs._zxReport != rhs._zxReport {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kkm_Proto_ReportResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ReportResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "report"),
    2: .standard(proto: "zx_report"),
  ]

  public var isInitialized: Bool {
    if self._report == nil {return false}
    if let v = self._zxReport, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._report) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._zxReport) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._report {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._zxReport {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kkm_Proto_ReportResponse, rhs: Kkm_Proto_ReportResponse) -> Bool {
    if lhs._report != rhs._report {return false}
    if lhs._zxReport != rhs._zxReport {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
