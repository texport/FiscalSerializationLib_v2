// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: message.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///*
/// @brief Команды.
/// 
/// Функционал взаимодействия ККМ и сервера описывается набором этих команд.
enum Kkm_Proto_CommandTypeEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int

  //// Отправка серверу служебного пакета.
  case commandSystem // = 0

  //// Отправка данных чека на сервер и обратное получение номера чека.
  case commandTicket // = 1

  //// Закрытие смены.
  case commandCloseShift // = 2

  //// Запрос на получение X, Z или иных отчетов.
  case commandReport // = 3

  //// Запрос на загрузку текущей версии номенклатуры.
  case commandNomenclature // = 4

  //// Запрос на получение информации о кассе.
  case commandInfo // = 5

  //// Внесение и снятие наличных денежных средств.
  case commandMoneyPlacement // = 6

  //// Отмена последней команды COMMAND_TICKET.
  case commandCancelTicket // = 7

  //// Запрос на авторизацию в системе.
  case commandAuth // = 8

  //// Зарезервировано
  case commandReserved // = 127

  init() {
    self = .commandSystem
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .commandSystem
    case 1: self = .commandTicket
    case 2: self = .commandCloseShift
    case 3: self = .commandReport
    case 4: self = .commandNomenclature
    case 5: self = .commandInfo
    case 6: self = .commandMoneyPlacement
    case 7: self = .commandCancelTicket
    case 8: self = .commandAuth
    case 127: self = .commandReserved
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .commandSystem: return 0
    case .commandTicket: return 1
    case .commandCloseShift: return 2
    case .commandReport: return 3
    case .commandNomenclature: return 4
    case .commandInfo: return 5
    case .commandMoneyPlacement: return 6
    case .commandCancelTicket: return 7
    case .commandAuth: return 8
    case .commandReserved: return 127
    }
  }

}

///*
/// @brief Коды ответов.
/// 
/// Сервер отвечает всегда с тем же кодом команды, с которым устройство
/// обратилось к нему. Дополнительно сервер отсылает специальную структуру
/// данных, содержащую код ответа и данные, специфичные для данного кода,
/// если они необходимы. Список кодов ответа общего характера перечислен здесь.
/// Специфические коды ответов для конкретных команд описаны в соответствующих
/// перечислениях.
enum Kkm_Proto_ResultTypeEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int

  //// Команда выполнена успешно.
  ////
  //// Касса работает в штатном режиме.
  case resultTypeOk // = 0

  //// Неизвестный ID устройства
  ////
  //// Аппарат не зарегистрирован в системе.
  case resultTypeUnknownID // = 1

  //// Неверный токен.
  ////
  //// Отправка данных невозможна, необходимо произвести сброс токена.
  case resultTypeInvalidToken // = 2

  //// Ошибка протокола.
  ////
  //// Касса обратилась к серверу с неправильно сформированным запросом.
  //// Может возникать, например, при несовместимости версий протоколов.
  case resultTypeProtocolError // = 3

  //// Неизвестная команда.
  ////
  //// ККМ обратился с кодом команды, неизвестном серверу.
  case resultTypeUnknownCommand // = 4

  //// Команда не поддерживается.
  ////
  //// ККМ обратился с кодом команды, функциональность которой недоступна
  //// клиенту.
  case resultTypeUnsupportedCommand // = 5

  //// Неверные настройки устройства.
  ////
  //// В настоящее время не поддерживается.
  case resultTypeInvalidConfiguration // = 6

  //// Использование SSL не разрешено.
  ////
  //// Использование защищенного соединения запрещено. Необходимо подключить
  //// услугу или использовать открытый канал связи.
  case resultTypeSslIsNotAllowed // = 7

  //// Неправильный номер запроса.
  ////
  //// Порядковый номер запроса @link headers_subsec REQNUM @endlink тот же, что
  //// и в предыдущем запросе, но @link headers_subsec TOKEN @endlink другой.
  case resultTypeInvalidRequestNumber // = 8

  //// Неправильная попытка отправки повторного запроса.
  ////
  //// @link headers_subsec REQNUM @endlink и @link headers_subsec TOKEN @endlink
  //// имеют те же значения, что и в предыдущем запросе, но код команды
  //// отличается.
  case resultTypeInvalidRetryRequest // = 9

  //// Невозможно сделать отмену чека.
  ////
  //// Можно отменить только последний чек, и при этом после этого чека не было
  //// отправлено ни одной команды, кроме служебной. 
  //// @deprecated
  case resultTypeCantCancelTicket // = 10

  //// Время открытой смены истекло.
  ////
  //// Если истек период, в течение которого смена может быть открыта, то сервер
  //// будет возвращать эту ошибку, пока не закроется смена.
  case resultTypeOpenShiftTimeoutExpired // = 11

  //// Неправильное имя или пароль.
  ////
  ////@deprecated используйте AuthResponse.
  case resultTypeInvalidLoginPassword // = 12

  //// Неверные входные данные.
  ////
  //// Для случаев, когда данные корректны с точки зрения протокола, но не верны
  //// в конкретном контексте.
  case resultTypeIncorrectRequestData // = 13

  //// Недостаточно наличных.
  ////
  //// Указывает на недостаточность наличных в кассе во время расходных операций.
  case resultTypeNotEnoughCash // = 14

  //// Касса заблокирована.
  case resultTypeBlocked // = 15

  //// Смена уже была открыта
  case resultTypeShiftAlreadyOpened // = 16

  //// Совпадает значение ИИН/БИН покупателя и продавца
  case resultTypeSameTaxpayerAndCustomer // = 17

  //// Сервис временно недоступен.
  ////
  //// Касса должна разорвать соединение, и далее пытаться соединяться и
  //// отправлять данные в течение @link comm_subsec общего времени на обработку
  //// транзакции @endlink, по истечении которого устройство должно разорвать
  //// соединение, перейти в аварийный режим и выдать соответствующее сообщение.
  case resultTypeServiceTemporarilyUnavailable // = 254

  //// Неизвестная ошибка.
  ////
  //// Касса должна разорвать соединение и далее пытаться соединяться и отправлять
  //// данные в течение @link comm_subsec общего времени на обработку
  //// транзакции @endlink, по истечении которого устройство должно разорвать
  //// соединение и выдать соответствующее сообщение.
  case resultTypeUnknownError // = 255

  init() {
    self = .resultTypeOk
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .resultTypeOk
    case 1: self = .resultTypeUnknownID
    case 2: self = .resultTypeInvalidToken
    case 3: self = .resultTypeProtocolError
    case 4: self = .resultTypeUnknownCommand
    case 5: self = .resultTypeUnsupportedCommand
    case 6: self = .resultTypeInvalidConfiguration
    case 7: self = .resultTypeSslIsNotAllowed
    case 8: self = .resultTypeInvalidRequestNumber
    case 9: self = .resultTypeInvalidRetryRequest
    case 10: self = .resultTypeCantCancelTicket
    case 11: self = .resultTypeOpenShiftTimeoutExpired
    case 12: self = .resultTypeInvalidLoginPassword
    case 13: self = .resultTypeIncorrectRequestData
    case 14: self = .resultTypeNotEnoughCash
    case 15: self = .resultTypeBlocked
    case 16: self = .resultTypeShiftAlreadyOpened
    case 17: self = .resultTypeSameTaxpayerAndCustomer
    case 254: self = .resultTypeServiceTemporarilyUnavailable
    case 255: self = .resultTypeUnknownError
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .resultTypeOk: return 0
    case .resultTypeUnknownID: return 1
    case .resultTypeInvalidToken: return 2
    case .resultTypeProtocolError: return 3
    case .resultTypeUnknownCommand: return 4
    case .resultTypeUnsupportedCommand: return 5
    case .resultTypeInvalidConfiguration: return 6
    case .resultTypeSslIsNotAllowed: return 7
    case .resultTypeInvalidRequestNumber: return 8
    case .resultTypeInvalidRetryRequest: return 9
    case .resultTypeCantCancelTicket: return 10
    case .resultTypeOpenShiftTimeoutExpired: return 11
    case .resultTypeInvalidLoginPassword: return 12
    case .resultTypeIncorrectRequestData: return 13
    case .resultTypeNotEnoughCash: return 14
    case .resultTypeBlocked: return 15
    case .resultTypeShiftAlreadyOpened: return 16
    case .resultTypeSameTaxpayerAndCustomer: return 17
    case .resultTypeServiceTemporarilyUnavailable: return 254
    case .resultTypeUnknownError: return 255
    }
  }

}

///*
/// @brief Статус ответа сервера.
/// 
/// Служит для определения состояния ответа сервера.
struct Kkm_Proto_Result: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Код ответа.
  ////
  //// Тип uint32 позволяет использовать весь диапазон значений этого типа,
  //// что дает возможность не ломать бинарную совместимость при расширении
  //// набора кодов ответов. Однако для каждой конкретной версии протокола данное
  //// поле должно иметь значения из диапазона, задаваемого типом
  //// ::ResultTypeEnum.
  var resultCode: UInt32 {
    get {return _resultCode ?? 0}
    set {_resultCode = newValue}
  }
  /// Returns true if `resultCode` has been explicitly set.
  var hasResultCode: Bool {return self._resultCode != nil}
  /// Clears the value of `resultCode`. Subsequent reads from it will return its default value.
  mutating func clearResultCode() {self._resultCode = nil}

  //// Строка ответа.
  ////
  //// Строка с текстом системного характера для обработки ошибок.
  var resultText: String {
    get {return _resultText ?? String()}
    set {_resultText = newValue}
  }
  /// Returns true if `resultText` has been explicitly set.
  var hasResultText: Bool {return self._resultText != nil}
  /// Clears the value of `resultText`. Subsequent reads from it will return its default value.
  mutating func clearResultText() {self._resultText = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _resultCode: UInt32? = nil
  fileprivate var _resultText: String? = nil
}

///*
/// @brief Запрос к серверу.
/// 
/// Содержит код команды, определяющий суть запроса и данные, связанные с этим
/// кодом.
struct Kkm_Proto_Request: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Код команды.
  ////
  //// Код команды из перечня доступных значений ::CommandTypeEnum.
  var command: Kkm_Proto_CommandTypeEnum {
    get {return _storage._command ?? .commandSystem}
    set {_uniqueStorage()._command = newValue}
  }
  /// Returns true if `command` has been explicitly set.
  var hasCommand: Bool {return _storage._command != nil}
  /// Clears the value of `command`. Subsequent reads from it will return its default value.
  mutating func clearCommand() {_uniqueStorage()._command = nil}

  //// Чековая транзакция.
  ////
  //// Данный параметр обязателен, если Request::command == ::COMMAND_TICKET.
  var ticket: Kkm_Proto_TicketRequest {
    get {return _storage._ticket ?? Kkm_Proto_TicketRequest()}
    set {_uniqueStorage()._ticket = newValue}
  }
  /// Returns true if `ticket` has been explicitly set.
  var hasTicket: Bool {return _storage._ticket != nil}
  /// Clears the value of `ticket`. Subsequent reads from it will return its default value.
  mutating func clearTicket() {_uniqueStorage()._ticket = nil}

  //// Закрытие смены.
  ////
  //// Данный параметр обязателен, если Request::command ==
  //// ::COMMAND_CLOSE_SHIFT.
  var closeShift: Kkm_Proto_CloseShiftRequest {
    get {return _storage._closeShift ?? Kkm_Proto_CloseShiftRequest()}
    set {_uniqueStorage()._closeShift = newValue}
  }
  /// Returns true if `closeShift` has been explicitly set.
  var hasCloseShift: Bool {return _storage._closeShift != nil}
  /// Clears the value of `closeShift`. Subsequent reads from it will return its default value.
  mutating func clearCloseShift() {_uniqueStorage()._closeShift = nil}

  //// Запрос отчёта.
  ////
  //// Данный параметр обязателен, если Request::command == ::COMMAND_REPORT.
  var report: Kkm_Proto_ReportRequest {
    get {return _storage._report ?? Kkm_Proto_ReportRequest()}
    set {_uniqueStorage()._report = newValue}
  }
  /// Returns true if `report` has been explicitly set.
  var hasReport: Bool {return _storage._report != nil}
  /// Clears the value of `report`. Subsequent reads from it will return its default value.
  mutating func clearReport() {_uniqueStorage()._report = nil}

  //// Запрос номенклатуры.
  ////
  //// Данный параметр обязателен, если Request::command ==
  //// ::COMMAND_NOMENCLATURE.
  var nomenclature: Kkm_Proto_NomenclatureRequest {
    get {return _storage._nomenclature ?? Kkm_Proto_NomenclatureRequest()}
    set {_uniqueStorage()._nomenclature = newValue}
  }
  /// Returns true if `nomenclature` has been explicitly set.
  var hasNomenclature: Bool {return _storage._nomenclature != nil}
  /// Clears the value of `nomenclature`. Subsequent reads from it will return its default value.
  mutating func clearNomenclature() {_uniqueStorage()._nomenclature = nil}

  //// Служебная информация.
  ////
  //// Может передаваться при Request::command == ::COMMAND_SYSTEM или совместно
  //// c другими командами.
  var service: Kkm_Proto_ServiceRequest {
    get {return _storage._service ?? Kkm_Proto_ServiceRequest()}
    set {_uniqueStorage()._service = newValue}
  }
  /// Returns true if `service` has been explicitly set.
  var hasService: Bool {return _storage._service != nil}
  /// Clears the value of `service`. Subsequent reads from it will return its default value.
  mutating func clearService() {_uniqueStorage()._service = nil}

  //// Снятие/внесение наличных.
  ////
  //// Данный параметр обязателен, если
  //// Request::command == ::COMMAND_MONEY_PLACEMENT.
  var moneyPlacement: Kkm_Proto_MoneyPlacementRequest {
    get {return _storage._moneyPlacement ?? Kkm_Proto_MoneyPlacementRequest()}
    set {_uniqueStorage()._moneyPlacement = newValue}
  }
  /// Returns true if `moneyPlacement` has been explicitly set.
  var hasMoneyPlacement: Bool {return _storage._moneyPlacement != nil}
  /// Clears the value of `moneyPlacement`. Subsequent reads from it will return its default value.
  mutating func clearMoneyPlacement() {_uniqueStorage()._moneyPlacement = nil}

  //// Аутентификация кассира.
  ////
  //// Данный параметр обязателен, если Request::command == ::COMMAND_AUTH.
  var auth: Kkm_Proto_AuthRequest {
    get {return _storage._auth ?? Kkm_Proto_AuthRequest()}
    set {_uniqueStorage()._auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  var hasAuth: Bool {return _storage._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  mutating func clearAuth() {_uniqueStorage()._auth = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// @brief Ответ сервера на запрос устройства.
/// 
/// Содержит код команды, с которым устройство обращалось к серверу, и данные,
/// связанные с этим кодом.
struct Kkm_Proto_Response: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  //// Код команды.
  ////
  //// Код команды из перечня доступных значений ::CommandTypeEnum. Должен быть
  //// равным коду команды, с которым устройство обратилось к серверу.
  var command: Kkm_Proto_CommandTypeEnum {
    get {return _storage._command ?? .commandSystem}
    set {_uniqueStorage()._command = newValue}
  }
  /// Returns true if `command` has been explicitly set.
  var hasCommand: Bool {return _storage._command != nil}
  /// Clears the value of `command`. Subsequent reads from it will return its default value.
  mutating func clearCommand() {_uniqueStorage()._command = nil}

  //// Статус ответа сервера.
  ////
  var result: Kkm_Proto_Result {
    get {return _storage._result ?? Kkm_Proto_Result()}
    set {_uniqueStorage()._result = newValue}
  }
  /// Returns true if `result` has been explicitly set.
  var hasResult: Bool {return _storage._result != nil}
  /// Clears the value of `result`. Subsequent reads from it will return its default value.
  mutating func clearResult() {_uniqueStorage()._result = nil}

  //// Ответ на команду ::COMMAND_TICKET
  ////
  var ticket: Kkm_Proto_TicketResponse {
    get {return _storage._ticket ?? Kkm_Proto_TicketResponse()}
    set {_uniqueStorage()._ticket = newValue}
  }
  /// Returns true if `ticket` has been explicitly set.
  var hasTicket: Bool {return _storage._ticket != nil}
  /// Clears the value of `ticket`. Subsequent reads from it will return its default value.
  mutating func clearTicket() {_uniqueStorage()._ticket = nil}

  //// Ответ на команду ::COMMAND_REPORT
  ////
  var report: Kkm_Proto_ReportResponse {
    get {return _storage._report ?? Kkm_Proto_ReportResponse()}
    set {_uniqueStorage()._report = newValue}
  }
  /// Returns true if `report` has been explicitly set.
  var hasReport: Bool {return _storage._report != nil}
  /// Clears the value of `report`. Subsequent reads from it will return its default value.
  mutating func clearReport() {_uniqueStorage()._report = nil}

  //// Ответ на команду ::COMMAND_NOMENCLATURE
  ////
  //// Содержит текущую версию номенклатуры.
  var nomenclature: Kkm_Proto_NomenclatureResponse {
    get {return _storage._nomenclature ?? Kkm_Proto_NomenclatureResponse()}
    set {_uniqueStorage()._nomenclature = newValue}
  }
  /// Returns true if `nomenclature` has been explicitly set.
  var hasNomenclature: Bool {return _storage._nomenclature != nil}
  /// Clears the value of `nomenclature`. Subsequent reads from it will return its default value.
  mutating func clearNomenclature() {_uniqueStorage()._nomenclature = nil}

  //// Служебная информация.
  ////
  //// Может передаваться как самостоятельный ответ на команду ::COMMAND_SYSTEM
  //// или совместно c ответами на другие команды.
  var service: Kkm_Proto_ServiceResponse {
    get {return _storage._service ?? Kkm_Proto_ServiceResponse()}
    set {_uniqueStorage()._service = newValue}
  }
  /// Returns true if `service` has been explicitly set.
  var hasService: Bool {return _storage._service != nil}
  /// Clears the value of `service`. Subsequent reads from it will return its default value.
  mutating func clearService() {_uniqueStorage()._service = nil}

  //// Ответ на команду ::COMMAND_AUTH
  ////
  var auth: Kkm_Proto_AuthResponse {
    get {return _storage._auth ?? Kkm_Proto_AuthResponse()}
    set {_uniqueStorage()._auth = newValue}
  }
  /// Returns true if `auth` has been explicitly set.
  var hasAuth: Bool {return _storage._auth != nil}
  /// Clears the value of `auth`. Subsequent reads from it will return its default value.
  mutating func clearAuth() {_uniqueStorage()._auth = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "kkm.proto"

extension Kkm_Proto_CommandTypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "COMMAND_SYSTEM"),
    1: .same(proto: "COMMAND_TICKET"),
    2: .same(proto: "COMMAND_CLOSE_SHIFT"),
    3: .same(proto: "COMMAND_REPORT"),
    4: .same(proto: "COMMAND_NOMENCLATURE"),
    5: .same(proto: "COMMAND_INFO"),
    6: .same(proto: "COMMAND_MONEY_PLACEMENT"),
    7: .same(proto: "COMMAND_CANCEL_TICKET"),
    8: .same(proto: "COMMAND_AUTH"),
    127: .same(proto: "COMMAND_RESERVED"),
  ]
}

extension Kkm_Proto_ResultTypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "RESULT_TYPE_OK"),
    1: .same(proto: "RESULT_TYPE_UNKNOWN_ID"),
    2: .same(proto: "RESULT_TYPE_INVALID_TOKEN"),
    3: .same(proto: "RESULT_TYPE_PROTOCOL_ERROR"),
    4: .same(proto: "RESULT_TYPE_UNKNOWN_COMMAND"),
    5: .same(proto: "RESULT_TYPE_UNSUPPORTED_COMMAND"),
    6: .same(proto: "RESULT_TYPE_INVALID_CONFIGURATION"),
    7: .same(proto: "RESULT_TYPE_SSL_IS_NOT_ALLOWED"),
    8: .same(proto: "RESULT_TYPE_INVALID_REQUEST_NUMBER"),
    9: .same(proto: "RESULT_TYPE_INVALID_RETRY_REQUEST"),
    10: .same(proto: "RESULT_TYPE_CANT_CANCEL_TICKET"),
    11: .same(proto: "RESULT_TYPE_OPEN_SHIFT_TIMEOUT_EXPIRED"),
    12: .same(proto: "RESULT_TYPE_INVALID_LOGIN_PASSWORD"),
    13: .same(proto: "RESULT_TYPE_INCORRECT_REQUEST_DATA"),
    14: .same(proto: "RESULT_TYPE_NOT_ENOUGH_CASH"),
    15: .same(proto: "RESULT_TYPE_BLOCKED"),
    16: .same(proto: "RESULT_TYPE_SHIFT_ALREADY_OPENED"),
    17: .same(proto: "RESULT_TYPE_SAME_TAXPAYER_AND_CUSTOMER"),
    254: .same(proto: "RESULT_TYPE_SERVICE_TEMPORARILY_UNAVAILABLE"),
    255: .same(proto: "RESULT_TYPE_UNKNOWN_ERROR"),
  ]
}

extension Kkm_Proto_Result: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Result"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "result_code"),
    2: .standard(proto: "result_text"),
  ]

  public var isInitialized: Bool {
    if self._resultCode == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._resultCode) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._resultText) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._resultCode {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._resultText {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kkm_Proto_Result, rhs: Kkm_Proto_Result) -> Bool {
    if lhs._resultCode != rhs._resultCode {return false}
    if lhs._resultText != rhs._resultText {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kkm_Proto_Request: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Request"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "command"),
    2: .same(proto: "ticket"),
    3: .standard(proto: "close_shift"),
    4: .same(proto: "report"),
    5: .same(proto: "nomenclature"),
    6: .same(proto: "service"),
    7: .standard(proto: "money_placement"),
    8: .same(proto: "auth"),
  ]

  fileprivate class _StorageClass {
    var _command: Kkm_Proto_CommandTypeEnum? = nil
    var _ticket: Kkm_Proto_TicketRequest? = nil
    var _closeShift: Kkm_Proto_CloseShiftRequest? = nil
    var _report: Kkm_Proto_ReportRequest? = nil
    var _nomenclature: Kkm_Proto_NomenclatureRequest? = nil
    var _service: Kkm_Proto_ServiceRequest? = nil
    var _moneyPlacement: Kkm_Proto_MoneyPlacementRequest? = nil
    var _auth: Kkm_Proto_AuthRequest? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _command = source._command
      _ticket = source._ticket
      _closeShift = source._closeShift
      _report = source._report
      _nomenclature = source._nomenclature
      _service = source._service
      _moneyPlacement = source._moneyPlacement
      _auth = source._auth
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._command == nil {return false}
      if let v = _storage._ticket, !v.isInitialized {return false}
      if let v = _storage._closeShift, !v.isInitialized {return false}
      if let v = _storage._report, !v.isInitialized {return false}
      if let v = _storage._nomenclature, !v.isInitialized {return false}
      if let v = _storage._service, !v.isInitialized {return false}
      if let v = _storage._moneyPlacement, !v.isInitialized {return false}
      if let v = _storage._auth, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._command) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._ticket) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._closeShift) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._report) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._nomenclature) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._service) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._moneyPlacement) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._auth) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._command {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._ticket {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._closeShift {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._report {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._nomenclature {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._service {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._moneyPlacement {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      try { if let v = _storage._auth {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kkm_Proto_Request, rhs: Kkm_Proto_Request) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._command != rhs_storage._command {return false}
        if _storage._ticket != rhs_storage._ticket {return false}
        if _storage._closeShift != rhs_storage._closeShift {return false}
        if _storage._report != rhs_storage._report {return false}
        if _storage._nomenclature != rhs_storage._nomenclature {return false}
        if _storage._service != rhs_storage._service {return false}
        if _storage._moneyPlacement != rhs_storage._moneyPlacement {return false}
        if _storage._auth != rhs_storage._auth {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kkm_Proto_Response: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".Response"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "command"),
    2: .same(proto: "result"),
    3: .same(proto: "ticket"),
    4: .same(proto: "report"),
    5: .same(proto: "nomenclature"),
    6: .same(proto: "service"),
    7: .same(proto: "auth"),
  ]

  fileprivate class _StorageClass {
    var _command: Kkm_Proto_CommandTypeEnum? = nil
    var _result: Kkm_Proto_Result? = nil
    var _ticket: Kkm_Proto_TicketResponse? = nil
    var _report: Kkm_Proto_ReportResponse? = nil
    var _nomenclature: Kkm_Proto_NomenclatureResponse? = nil
    var _service: Kkm_Proto_ServiceResponse? = nil
    var _auth: Kkm_Proto_AuthResponse? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _command = source._command
      _result = source._result
      _ticket = source._ticket
      _report = source._report
      _nomenclature = source._nomenclature
      _service = source._service
      _auth = source._auth
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._command == nil {return false}
      if _storage._result == nil {return false}
      if let v = _storage._result, !v.isInitialized {return false}
      if let v = _storage._ticket, !v.isInitialized {return false}
      if let v = _storage._report, !v.isInitialized {return false}
      if let v = _storage._nomenclature, !v.isInitialized {return false}
      if let v = _storage._service, !v.isInitialized {return false}
      if let v = _storage._auth, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._command) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._result) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._ticket) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._report) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._nomenclature) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._service) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._auth) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._command {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._result {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._ticket {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._report {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._nomenclature {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._service {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._auth {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kkm_Proto_Response, rhs: Kkm_Proto_Response) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._command != rhs_storage._command {return false}
        if _storage._result != rhs_storage._result {return false}
        if _storage._ticket != rhs_storage._ticket {return false}
        if _storage._report != rhs_storage._report {return false}
        if _storage._nomenclature != rhs_storage._nomenclature {return false}
        if _storage._service != rhs_storage._service {return false}
        if _storage._auth != rhs_storage._auth {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
