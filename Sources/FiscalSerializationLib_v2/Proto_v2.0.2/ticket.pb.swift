// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: ticket.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Kkm_Proto_TicketRequest: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var operation: Kkm_Proto_OperationTypeEnum {
    get {return _storage._operation ?? .operationBuy}
    set {_uniqueStorage()._operation = newValue}
  }
  /// Returns true if `operation` has been explicitly set.
  var hasOperation: Bool {return _storage._operation != nil}
  /// Clears the value of `operation`. Subsequent reads from it will return its default value.
  mutating func clearOperation() {_uniqueStorage()._operation = nil}

  var dateTime: Kkm_Proto_DateTime {
    get {return _storage._dateTime ?? Kkm_Proto_DateTime()}
    set {_uniqueStorage()._dateTime = newValue}
  }
  /// Returns true if `dateTime` has been explicitly set.
  var hasDateTime: Bool {return _storage._dateTime != nil}
  /// Clears the value of `dateTime`. Subsequent reads from it will return its default value.
  mutating func clearDateTime() {_uniqueStorage()._dateTime = nil}

  var `operator`: Kkm_Proto_Operator {
    get {return _storage._operator ?? Kkm_Proto_Operator()}
    set {_uniqueStorage()._operator = newValue}
  }
  /// Returns true if ``operator`` has been explicitly set.
  var hasOperator: Bool {return _storage._operator != nil}
  /// Clears the value of ``operator``. Subsequent reads from it will return its default value.
  mutating func clearOperator() {_uniqueStorage()._operator = nil}

  /// optional since version 200
  var domain: Kkm_Proto_TicketRequest.Domain {
    get {return _storage._domain ?? Kkm_Proto_TicketRequest.Domain()}
    set {_uniqueStorage()._domain = newValue}
  }
  /// Returns true if `domain` has been explicitly set.
  var hasDomain: Bool {return _storage._domain != nil}
  /// Clears the value of `domain`. Subsequent reads from it will return its default value.
  mutating func clearDomain() {_uniqueStorage()._domain = nil}

  var items: [Kkm_Proto_TicketRequest.Item] {
    get {return _storage._items}
    set {_uniqueStorage()._items = newValue}
  }

  var payments: [Kkm_Proto_TicketRequest.Payment] {
    get {return _storage._payments}
    set {_uniqueStorage()._payments = newValue}
  }

  var taxes: [Kkm_Proto_TicketRequest.Tax] {
    get {return _storage._taxes}
    set {_uniqueStorage()._taxes = newValue}
  }

  var amounts: Kkm_Proto_TicketRequest.Amounts {
    get {return _storage._amounts ?? Kkm_Proto_TicketRequest.Amounts()}
    set {_uniqueStorage()._amounts = newValue}
  }
  /// Returns true if `amounts` has been explicitly set.
  var hasAmounts: Bool {return _storage._amounts != nil}
  /// Clears the value of `amounts`. Subsequent reads from it will return its default value.
  mutating func clearAmounts() {_uniqueStorage()._amounts = nil}

  var extensionOptions: Kkm_Proto_TicketRequest.ExtensionOptions {
    get {return _storage._extensionOptions ?? Kkm_Proto_TicketRequest.ExtensionOptions()}
    set {_uniqueStorage()._extensionOptions = newValue}
  }
  /// Returns true if `extensionOptions` has been explicitly set.
  var hasExtensionOptions: Bool {return _storage._extensionOptions != nil}
  /// Clears the value of `extensionOptions`. Subsequent reads from it will return its default value.
  mutating func clearExtensionOptions() {_uniqueStorage()._extensionOptions = nil}

  var offlineTicketNumber: UInt32 {
    get {return _storage._offlineTicketNumber ?? 0}
    set {_uniqueStorage()._offlineTicketNumber = newValue}
  }
  /// Returns true if `offlineTicketNumber` has been explicitly set.
  var hasOfflineTicketNumber: Bool {return _storage._offlineTicketNumber != nil}
  /// Clears the value of `offlineTicketNumber`. Subsequent reads from it will return its default value.
  mutating func clearOfflineTicketNumber() {_uniqueStorage()._offlineTicketNumber = nil}

  /// for compatibility with versions < 200
  var printedDocumentNumberOld: String {
    get {return _storage._printedDocumentNumberOld ?? String()}
    set {_uniqueStorage()._printedDocumentNumberOld = newValue}
  }
  /// Returns true if `printedDocumentNumberOld` has been explicitly set.
  var hasPrintedDocumentNumberOld: Bool {return _storage._printedDocumentNumberOld != nil}
  /// Clears the value of `printedDocumentNumberOld`. Subsequent reads from it will return its default value.
  mutating func clearPrintedDocumentNumberOld() {_uniqueStorage()._printedDocumentNumberOld = nil}

  /// ticket in one string, delimiter - \n
  var printedTicket: String {
    get {return _storage._printedTicket ?? String()}
    set {_uniqueStorage()._printedTicket = newValue}
  }
  /// Returns true if `printedTicket` has been explicitly set.
  var hasPrintedTicket: Bool {return _storage._printedTicket != nil}
  /// Clears the value of `printedTicket`. Subsequent reads from it will return its default value.
  mutating func clearPrintedTicket() {_uniqueStorage()._printedTicket = nil}

  //// @deprecated используйте ServiceRequest
  //// поле игнорируется ККМ сервером
  var adInfos: [Kkm_Proto_TicketAdInfo] {
    get {return _storage._adInfos}
    set {_uniqueStorage()._adInfos = newValue}
  }

  var frShiftNumber: UInt32 {
    get {return _storage._frShiftNumber ?? 0}
    set {_uniqueStorage()._frShiftNumber = newValue}
  }
  /// Returns true if `frShiftNumber` has been explicitly set.
  var hasFrShiftNumber: Bool {return _storage._frShiftNumber != nil}
  /// Clears the value of `frShiftNumber`. Subsequent reads from it will return its default value.
  mutating func clearFrShiftNumber() {_uniqueStorage()._frShiftNumber = nil}

  /// since protocol version 125
  var shiftDocumentNumber: UInt32 {
    get {return _storage._shiftDocumentNumber ?? 0}
    set {_uniqueStorage()._shiftDocumentNumber = newValue}
  }
  /// Returns true if `shiftDocumentNumber` has been explicitly set.
  var hasShiftDocumentNumber: Bool {return _storage._shiftDocumentNumber != nil}
  /// Clears the value of `shiftDocumentNumber`. Subsequent reads from it will return its default value.
  mutating func clearShiftDocumentNumber() {_uniqueStorage()._shiftDocumentNumber = nil}

  /// since version 201
  var printedDocumentNumber: UInt64 {
    get {return _storage._printedDocumentNumber ?? 0}
    set {_uniqueStorage()._printedDocumentNumber = newValue}
  }
  /// Returns true if `printedDocumentNumber` has been explicitly set.
  var hasPrintedDocumentNumber: Bool {return _storage._printedDocumentNumber != nil}
  /// Clears the value of `printedDocumentNumber`. Subsequent reads from it will return its default value.
  mutating func clearPrintedDocumentNumber() {_uniqueStorage()._printedDocumentNumber = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  struct Tax: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var taxType: UInt32 {
      get {return _taxType ?? 0}
      set {_taxType = newValue}
    }
    /// Returns true if `taxType` has been explicitly set.
    var hasTaxType: Bool {return self._taxType != nil}
    /// Clears the value of `taxType`. Subsequent reads from it will return its default value.
    mutating func clearTaxType() {self._taxType = nil}

    /// optional since version 201
    var taxationType: UInt32 {
      get {return _taxationType ?? 0}
      set {_taxationType = newValue}
    }
    /// Returns true if `taxationType` has been explicitly set.
    var hasTaxationType: Bool {return self._taxationType != nil}
    /// Clears the value of `taxationType`. Subsequent reads from it will return its default value.
    mutating func clearTaxationType() {self._taxationType = nil}

    var percent: UInt32 {
      get {return _percent ?? 0}
      set {_percent = newValue}
    }
    /// Returns true if `percent` has been explicitly set.
    var hasPercent: Bool {return self._percent != nil}
    /// Clears the value of `percent`. Subsequent reads from it will return its default value.
    mutating func clearPercent() {self._percent = nil}

    var sum: Kkm_Proto_Money {
      get {return _sum ?? Kkm_Proto_Money()}
      set {_sum = newValue}
    }
    /// Returns true if `sum` has been explicitly set.
    var hasSum: Bool {return self._sum != nil}
    /// Clears the value of `sum`. Subsequent reads from it will return its default value.
    mutating func clearSum() {self._sum = nil}

    var isInTotalSum: Bool {
      get {return _isInTotalSum ?? false}
      set {_isInTotalSum = newValue}
    }
    /// Returns true if `isInTotalSum` has been explicitly set.
    var hasIsInTotalSum: Bool {return self._isInTotalSum != nil}
    /// Clears the value of `isInTotalSum`. Subsequent reads from it will return its default value.
    mutating func clearIsInTotalSum() {self._isInTotalSum = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _taxType: UInt32? = nil
    fileprivate var _taxationType: UInt32? = nil
    fileprivate var _percent: UInt32? = nil
    fileprivate var _sum: Kkm_Proto_Money? = nil
    fileprivate var _isInTotalSum: Bool? = nil
  }

  /// describes markups discounts, storno
  struct Modifier: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// required since veriosn 201
    var name: String {
      get {return _name ?? String()}
      set {_name = newValue}
    }
    /// Returns true if `name` has been explicitly set.
    var hasName: Bool {return self._name != nil}
    /// Clears the value of `name`. Subsequent reads from it will return its default value.
    mutating func clearName() {self._name = nil}

    var sum: Kkm_Proto_Money {
      get {return _sum ?? Kkm_Proto_Money()}
      set {_sum = newValue}
    }
    /// Returns true if `sum` has been explicitly set.
    var hasSum: Bool {return self._sum != nil}
    /// Clears the value of `sum`. Subsequent reads from it will return its default value.
    mutating func clearSum() {self._sum = nil}

    var taxes: [Kkm_Proto_TicketRequest.Tax] = []

    /// since protocol version 125
    var auxiliary: [Kkm_Proto_KeyValuePair] = []

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _name: String? = nil
    fileprivate var _sum: Kkm_Proto_Money? = nil
  }

  /// describes one position in ticket
  struct Item: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: Kkm_Proto_TicketRequest.Item.ItemTypeEnum {
      get {return _storage._type ?? .itemTypeCommodity}
      set {_uniqueStorage()._type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    var hasType: Bool {return _storage._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    mutating func clearType() {_uniqueStorage()._type = nil}

    /// required if type == ITEM_TYPE_COMMODITY
    var commodity: Kkm_Proto_TicketRequest.Item.Commodity {
      get {return _storage._commodity ?? Kkm_Proto_TicketRequest.Item.Commodity()}
      set {_uniqueStorage()._commodity = newValue}
    }
    /// Returns true if `commodity` has been explicitly set.
    var hasCommodity: Bool {return _storage._commodity != nil}
    /// Clears the value of `commodity`. Subsequent reads from it will return its default value.
    mutating func clearCommodity() {_uniqueStorage()._commodity = nil}

    /// required if type == ITEM_TYPE_STORNO_COMMODITY
    var stornoCommodity: Kkm_Proto_TicketRequest.Item.StornoCommodity {
      get {return _storage._stornoCommodity ?? Kkm_Proto_TicketRequest.Item.StornoCommodity()}
      set {_uniqueStorage()._stornoCommodity = newValue}
    }
    /// Returns true if `stornoCommodity` has been explicitly set.
    var hasStornoCommodity: Bool {return _storage._stornoCommodity != nil}
    /// Clears the value of `stornoCommodity`. Subsequent reads from it will return its default value.
    mutating func clearStornoCommodity() {_uniqueStorage()._stornoCommodity = nil}

    /// required if type == ITEM_TYPE_MARKUP
    var markup: Kkm_Proto_TicketRequest.Modifier {
      get {return _storage._markup ?? Kkm_Proto_TicketRequest.Modifier()}
      set {_uniqueStorage()._markup = newValue}
    }
    /// Returns true if `markup` has been explicitly set.
    var hasMarkup: Bool {return _storage._markup != nil}
    /// Clears the value of `markup`. Subsequent reads from it will return its default value.
    mutating func clearMarkup() {_uniqueStorage()._markup = nil}

    /// required if type == ITEM_TYPE_STORNO_MARKUP
    var stornoMarkup: Kkm_Proto_TicketRequest.Modifier {
      get {return _storage._stornoMarkup ?? Kkm_Proto_TicketRequest.Modifier()}
      set {_uniqueStorage()._stornoMarkup = newValue}
    }
    /// Returns true if `stornoMarkup` has been explicitly set.
    var hasStornoMarkup: Bool {return _storage._stornoMarkup != nil}
    /// Clears the value of `stornoMarkup`. Subsequent reads from it will return its default value.
    mutating func clearStornoMarkup() {_uniqueStorage()._stornoMarkup = nil}

    /// required if type == ITEM_TYPE_DISCOUNT
    var discount: Kkm_Proto_TicketRequest.Modifier {
      get {return _storage._discount ?? Kkm_Proto_TicketRequest.Modifier()}
      set {_uniqueStorage()._discount = newValue}
    }
    /// Returns true if `discount` has been explicitly set.
    var hasDiscount: Bool {return _storage._discount != nil}
    /// Clears the value of `discount`. Subsequent reads from it will return its default value.
    mutating func clearDiscount() {_uniqueStorage()._discount = nil}

    /// required if type == ITEM_TYPE_STORNO_DISCOUNT
    var stornoDiscount: Kkm_Proto_TicketRequest.Modifier {
      get {return _storage._stornoDiscount ?? Kkm_Proto_TicketRequest.Modifier()}
      set {_uniqueStorage()._stornoDiscount = newValue}
    }
    /// Returns true if `stornoDiscount` has been explicitly set.
    var hasStornoDiscount: Bool {return _storage._stornoDiscount != nil}
    /// Clears the value of `stornoDiscount`. Subsequent reads from it will return its default value.
    mutating func clearStornoDiscount() {_uniqueStorage()._stornoDiscount = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    enum ItemTypeEnum: SwiftProtobuf.Enum, Swift.CaseIterable {
      typealias RawValue = Int
      case itemTypeCommodity // = 1
      case itemTypeStornoCommodity // = 2
      case itemTypeMarkup // = 3
      case itemTypeStornoMarkup // = 4
      case itemTypeDiscount // = 5
      case itemTypeStornoDiscount // = 6

      init() {
        self = .itemTypeCommodity
      }

      init?(rawValue: Int) {
        switch rawValue {
        case 1: self = .itemTypeCommodity
        case 2: self = .itemTypeStornoCommodity
        case 3: self = .itemTypeMarkup
        case 4: self = .itemTypeStornoMarkup
        case 5: self = .itemTypeDiscount
        case 6: self = .itemTypeStornoDiscount
        default: return nil
        }
      }

      var rawValue: Int {
        switch self {
        case .itemTypeCommodity: return 1
        case .itemTypeStornoCommodity: return 2
        case .itemTypeMarkup: return 3
        case .itemTypeStornoMarkup: return 4
        case .itemTypeDiscount: return 5
        case .itemTypeStornoDiscount: return 6
        }
      }

    }

    struct Commodity: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      /// uint64 since version 201
      var code: UInt64 {
        get {return _code ?? 0}
        set {_code = newValue}
      }
      /// Returns true if `code` has been explicitly set.
      var hasCode: Bool {return self._code != nil}
      /// Clears the value of `code`. Subsequent reads from it will return its default value.
      mutating func clearCode() {self._code = nil}

      /// required since veriosn 201
      var name: String {
        get {return _name ?? String()}
        set {_name = newValue}
      }
      /// Returns true if `name` has been explicitly set.
      var hasName: Bool {return self._name != nil}
      /// Clears the value of `name`. Subsequent reads from it will return its default value.
      mutating func clearName() {self._name = nil}

      var sectionCode: String {
        get {return _sectionCode ?? String()}
        set {_sectionCode = newValue}
      }
      /// Returns true if `sectionCode` has been explicitly set.
      var hasSectionCode: Bool {return self._sectionCode != nil}
      /// Clears the value of `sectionCode`. Subsequent reads from it will return its default value.
      mutating func clearSectionCode() {self._sectionCode = nil}

      var quantity: UInt32 {
        get {return _quantity ?? 0}
        set {_quantity = newValue}
      }
      /// Returns true if `quantity` has been explicitly set.
      var hasQuantity: Bool {return self._quantity != nil}
      /// Clears the value of `quantity`. Subsequent reads from it will return its default value.
      mutating func clearQuantity() {self._quantity = nil}

      var price: Kkm_Proto_Money {
        get {return _price ?? Kkm_Proto_Money()}
        set {_price = newValue}
      }
      /// Returns true if `price` has been explicitly set.
      var hasPrice: Bool {return self._price != nil}
      /// Clears the value of `price`. Subsequent reads from it will return its default value.
      mutating func clearPrice() {self._price = nil}

      var sum: Kkm_Proto_Money {
        get {return _sum ?? Kkm_Proto_Money()}
        set {_sum = newValue}
      }
      /// Returns true if `sum` has been explicitly set.
      var hasSum: Bool {return self._sum != nil}
      /// Clears the value of `sum`. Subsequent reads from it will return its default value.
      mutating func clearSum() {self._sum = nil}

      var taxes: [Kkm_Proto_TicketRequest.Tax] = []

      var exciseStamp: String {
        get {return _exciseStamp ?? String()}
        set {_exciseStamp = newValue}
      }
      /// Returns true if `exciseStamp` has been explicitly set.
      var hasExciseStamp: Bool {return self._exciseStamp != nil}
      /// Clears the value of `exciseStamp`. Subsequent reads from it will return its default value.
      mutating func clearExciseStamp() {self._exciseStamp = nil}

      /// since protocol version 125
      var auxiliary: [Kkm_Proto_KeyValuePair] = []

      var physicalLabel: String {
        get {return _physicalLabel ?? String()}
        set {_physicalLabel = newValue}
      }
      /// Returns true if `physicalLabel` has been explicitly set.
      var hasPhysicalLabel: Bool {return self._physicalLabel != nil}
      /// Clears the value of `physicalLabel`. Subsequent reads from it will return its default value.
      mutating func clearPhysicalLabel() {self._physicalLabel = nil}

      var productID: String {
        get {return _productID ?? String()}
        set {_productID = newValue}
      }
      /// Returns true if `productID` has been explicitly set.
      var hasProductID: Bool {return self._productID != nil}
      /// Clears the value of `productID`. Subsequent reads from it will return its default value.
      mutating func clearProductID() {self._productID = nil}

      var barcode: String {
        get {return _barcode ?? String()}
        set {_barcode = newValue}
      }
      /// Returns true if `barcode` has been explicitly set.
      var hasBarcode: Bool {return self._barcode != nil}
      /// Clears the value of `barcode`. Subsequent reads from it will return its default value.
      mutating func clearBarcode() {self._barcode = nil}

      var measureUnitCode: String {
        get {return _measureUnitCode ?? String()}
        set {_measureUnitCode = newValue}
      }
      /// Returns true if `measureUnitCode` has been explicitly set.
      var hasMeasureUnitCode: Bool {return self._measureUnitCode != nil}
      /// Clears the value of `measureUnitCode`. Subsequent reads from it will return its default value.
      mutating func clearMeasureUnitCode() {self._measureUnitCode = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _code: UInt64? = nil
      fileprivate var _name: String? = nil
      fileprivate var _sectionCode: String? = nil
      fileprivate var _quantity: UInt32? = nil
      fileprivate var _price: Kkm_Proto_Money? = nil
      fileprivate var _sum: Kkm_Proto_Money? = nil
      fileprivate var _exciseStamp: String? = nil
      fileprivate var _physicalLabel: String? = nil
      fileprivate var _productID: String? = nil
      fileprivate var _barcode: String? = nil
      fileprivate var _measureUnitCode: String? = nil
    }

    struct StornoCommodity: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var name: String {
        get {return _name ?? String()}
        set {_name = newValue}
      }
      /// Returns true if `name` has been explicitly set.
      var hasName: Bool {return self._name != nil}
      /// Clears the value of `name`. Subsequent reads from it will return its default value.
      mutating func clearName() {self._name = nil}

      var sectionCode: String {
        get {return _sectionCode ?? String()}
        set {_sectionCode = newValue}
      }
      /// Returns true if `sectionCode` has been explicitly set.
      var hasSectionCode: Bool {return self._sectionCode != nil}
      /// Clears the value of `sectionCode`. Subsequent reads from it will return its default value.
      mutating func clearSectionCode() {self._sectionCode = nil}

      var quantity: UInt32 {
        get {return _quantity ?? 0}
        set {_quantity = newValue}
      }
      /// Returns true if `quantity` has been explicitly set.
      var hasQuantity: Bool {return self._quantity != nil}
      /// Clears the value of `quantity`. Subsequent reads from it will return its default value.
      mutating func clearQuantity() {self._quantity = nil}

      var price: Kkm_Proto_Money {
        get {return _price ?? Kkm_Proto_Money()}
        set {_price = newValue}
      }
      /// Returns true if `price` has been explicitly set.
      var hasPrice: Bool {return self._price != nil}
      /// Clears the value of `price`. Subsequent reads from it will return its default value.
      mutating func clearPrice() {self._price = nil}

      var sum: Kkm_Proto_Money {
        get {return _sum ?? Kkm_Proto_Money()}
        set {_sum = newValue}
      }
      /// Returns true if `sum` has been explicitly set.
      var hasSum: Bool {return self._sum != nil}
      /// Clears the value of `sum`. Subsequent reads from it will return its default value.
      mutating func clearSum() {self._sum = nil}

      var taxes: [Kkm_Proto_TicketRequest.Tax] = []

      var exciseStamp: String {
        get {return _exciseStamp ?? String()}
        set {_exciseStamp = newValue}
      }
      /// Returns true if `exciseStamp` has been explicitly set.
      var hasExciseStamp: Bool {return self._exciseStamp != nil}
      /// Clears the value of `exciseStamp`. Subsequent reads from it will return its default value.
      mutating func clearExciseStamp() {self._exciseStamp = nil}

      /// since protocol version 125
      var auxiliary: [Kkm_Proto_KeyValuePair] = []

      var physicalLabel: String {
        get {return _physicalLabel ?? String()}
        set {_physicalLabel = newValue}
      }
      /// Returns true if `physicalLabel` has been explicitly set.
      var hasPhysicalLabel: Bool {return self._physicalLabel != nil}
      /// Clears the value of `physicalLabel`. Subsequent reads from it will return its default value.
      mutating func clearPhysicalLabel() {self._physicalLabel = nil}

      var productID: String {
        get {return _productID ?? String()}
        set {_productID = newValue}
      }
      /// Returns true if `productID` has been explicitly set.
      var hasProductID: Bool {return self._productID != nil}
      /// Clears the value of `productID`. Subsequent reads from it will return its default value.
      mutating func clearProductID() {self._productID = nil}

      var barcode: String {
        get {return _barcode ?? String()}
        set {_barcode = newValue}
      }
      /// Returns true if `barcode` has been explicitly set.
      var hasBarcode: Bool {return self._barcode != nil}
      /// Clears the value of `barcode`. Subsequent reads from it will return its default value.
      mutating func clearBarcode() {self._barcode = nil}

      var measureUnitCode: String {
        get {return _measureUnitCode ?? String()}
        set {_measureUnitCode = newValue}
      }
      /// Returns true if `measureUnitCode` has been explicitly set.
      var hasMeasureUnitCode: Bool {return self._measureUnitCode != nil}
      /// Clears the value of `measureUnitCode`. Subsequent reads from it will return its default value.
      mutating func clearMeasureUnitCode() {self._measureUnitCode = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _name: String? = nil
      fileprivate var _sectionCode: String? = nil
      fileprivate var _quantity: UInt32? = nil
      fileprivate var _price: Kkm_Proto_Money? = nil
      fileprivate var _sum: Kkm_Proto_Money? = nil
      fileprivate var _exciseStamp: String? = nil
      fileprivate var _physicalLabel: String? = nil
      fileprivate var _productID: String? = nil
      fileprivate var _barcode: String? = nil
      fileprivate var _measureUnitCode: String? = nil
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct Domain: @unchecked Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// not required since 200
    var type: Kkm_Proto_DomainTypeEnum {
      get {return _storage._type ?? .domainTrading}
      set {_uniqueStorage()._type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    var hasType: Bool {return _storage._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    mutating func clearType() {_uniqueStorage()._type = nil}

    var services: Kkm_Proto_TicketRequest.Domain.Services {
      get {return _storage._services ?? Kkm_Proto_TicketRequest.Domain.Services()}
      set {_uniqueStorage()._services = newValue}
    }
    /// Returns true if `services` has been explicitly set.
    var hasServices: Bool {return _storage._services != nil}
    /// Clears the value of `services`. Subsequent reads from it will return its default value.
    mutating func clearServices() {_uniqueStorage()._services = nil}

    var gasoil: Kkm_Proto_TicketRequest.Domain.GasOil {
      get {return _storage._gasoil ?? Kkm_Proto_TicketRequest.Domain.GasOil()}
      set {_uniqueStorage()._gasoil = newValue}
    }
    /// Returns true if `gasoil` has been explicitly set.
    var hasGasoil: Bool {return _storage._gasoil != nil}
    /// Clears the value of `gasoil`. Subsequent reads from it will return its default value.
    mutating func clearGasoil() {_uniqueStorage()._gasoil = nil}

    var taxi: Kkm_Proto_TicketRequest.Domain.Taxi {
      get {return _storage._taxi ?? Kkm_Proto_TicketRequest.Domain.Taxi()}
      set {_uniqueStorage()._taxi = newValue}
    }
    /// Returns true if `taxi` has been explicitly set.
    var hasTaxi: Bool {return _storage._taxi != nil}
    /// Clears the value of `taxi`. Subsequent reads from it will return its default value.
    mutating func clearTaxi() {_uniqueStorage()._taxi = nil}

    var parking: Kkm_Proto_TicketRequest.Domain.Parking {
      get {return _storage._parking ?? Kkm_Proto_TicketRequest.Domain.Parking()}
      set {_uniqueStorage()._parking = newValue}
    }
    /// Returns true if `parking` has been explicitly set.
    var hasParking: Bool {return _storage._parking != nil}
    /// Clears the value of `parking`. Subsequent reads from it will return its default value.
    mutating func clearParking() {_uniqueStorage()._parking = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    ///*
    /// @brief Сфера оказания услуг, отели и рестораны.
    /// 
    /// На текущий момент не используется.
    struct Services: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var accountNumber: String {
        get {return _accountNumber ?? String()}
        set {_accountNumber = newValue}
      }
      /// Returns true if `accountNumber` has been explicitly set.
      var hasAccountNumber: Bool {return self._accountNumber != nil}
      /// Clears the value of `accountNumber`. Subsequent reads from it will return its default value.
      mutating func clearAccountNumber() {self._accountNumber = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _accountNumber: String? = nil
    }

    ///*
    /// @brief Сфера торговли нефтепродуктами.
    /// 
    /// На текущий момент не используется.
    struct GasOil: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var correctionNumber: String {
        get {return _correctionNumber ?? String()}
        set {_correctionNumber = newValue}
      }
      /// Returns true if `correctionNumber` has been explicitly set.
      var hasCorrectionNumber: Bool {return self._correctionNumber != nil}
      /// Clears the value of `correctionNumber`. Subsequent reads from it will return its default value.
      mutating func clearCorrectionNumber() {self._correctionNumber = nil}

      var correctionSum: Kkm_Proto_Money {
        get {return _correctionSum ?? Kkm_Proto_Money()}
        set {_correctionSum = newValue}
      }
      /// Returns true if `correctionSum` has been explicitly set.
      var hasCorrectionSum: Bool {return self._correctionSum != nil}
      /// Clears the value of `correctionSum`. Subsequent reads from it will return its default value.
      mutating func clearCorrectionSum() {self._correctionSum = nil}

      var cardNumber: String {
        get {return _cardNumber ?? String()}
        set {_cardNumber = newValue}
      }
      /// Returns true if `cardNumber` has been explicitly set.
      var hasCardNumber: Bool {return self._cardNumber != nil}
      /// Clears the value of `cardNumber`. Subsequent reads from it will return its default value.
      mutating func clearCardNumber() {self._cardNumber = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _correctionNumber: String? = nil
      fileprivate var _correctionSum: Kkm_Proto_Money? = nil
      fileprivate var _cardNumber: String? = nil
    }

    ///*
    /// @brief Такси.
    /// 
    /// На текущий момент не используется.
    struct Taxi: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var carNumber: String {
        get {return _carNumber ?? String()}
        set {_carNumber = newValue}
      }
      /// Returns true if `carNumber` has been explicitly set.
      var hasCarNumber: Bool {return self._carNumber != nil}
      /// Clears the value of `carNumber`. Subsequent reads from it will return its default value.
      mutating func clearCarNumber() {self._carNumber = nil}

      var isOrder: Bool {
        get {return _isOrder ?? false}
        set {_isOrder = newValue}
      }
      /// Returns true if `isOrder` has been explicitly set.
      var hasIsOrder: Bool {return self._isOrder != nil}
      /// Clears the value of `isOrder`. Subsequent reads from it will return its default value.
      mutating func clearIsOrder() {self._isOrder = nil}

      var currentFee: Kkm_Proto_Money {
        get {return _currentFee ?? Kkm_Proto_Money()}
        set {_currentFee = newValue}
      }
      /// Returns true if `currentFee` has been explicitly set.
      var hasCurrentFee: Bool {return self._currentFee != nil}
      /// Clears the value of `currentFee`. Subsequent reads from it will return its default value.
      mutating func clearCurrentFee() {self._currentFee = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _carNumber: String? = nil
      fileprivate var _isOrder: Bool? = nil
      fileprivate var _currentFee: Kkm_Proto_Money? = nil
    }

    ///*
    /// @brief Парковки.
    /// 
    /// На текущий момент не используется.
    struct Parking: Sendable {
      // SwiftProtobuf.Message conformance is added in an extension below. See the
      // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
      // methods supported on all messages.

      var beginTime: Kkm_Proto_DateTime {
        get {return _beginTime ?? Kkm_Proto_DateTime()}
        set {_beginTime = newValue}
      }
      /// Returns true if `beginTime` has been explicitly set.
      var hasBeginTime: Bool {return self._beginTime != nil}
      /// Clears the value of `beginTime`. Subsequent reads from it will return its default value.
      mutating func clearBeginTime() {self._beginTime = nil}

      var endTime: Kkm_Proto_DateTime {
        get {return _endTime ?? Kkm_Proto_DateTime()}
        set {_endTime = newValue}
      }
      /// Returns true if `endTime` has been explicitly set.
      var hasEndTime: Bool {return self._endTime != nil}
      /// Clears the value of `endTime`. Subsequent reads from it will return its default value.
      mutating func clearEndTime() {self._endTime = nil}

      var unknownFields = SwiftProtobuf.UnknownStorage()

      init() {}

      fileprivate var _beginTime: Kkm_Proto_DateTime? = nil
      fileprivate var _endTime: Kkm_Proto_DateTime? = nil
    }

    init() {}

    fileprivate var _storage = _StorageClass.defaultInstance
  }

  struct ExtensionOptions: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var customerEmail: String {
      get {return _customerEmail ?? String()}
      set {_customerEmail = newValue}
    }
    /// Returns true if `customerEmail` has been explicitly set.
    var hasCustomerEmail: Bool {return self._customerEmail != nil}
    /// Clears the value of `customerEmail`. Subsequent reads from it will return its default value.
    mutating func clearCustomerEmail() {self._customerEmail = nil}

    var customerPhone: String {
      get {return _customerPhone ?? String()}
      set {_customerPhone = newValue}
    }
    /// Returns true if `customerPhone` has been explicitly set.
    var hasCustomerPhone: Bool {return self._customerPhone != nil}
    /// Clears the value of `customerPhone`. Subsequent reads from it will return its default value.
    mutating func clearCustomerPhone() {self._customerPhone = nil}

    /// since protocol version 125
    var auxiliary: [Kkm_Proto_KeyValuePair] = []

    var customerIinOrBin: String {
      get {return _customerIinOrBin ?? String()}
      set {_customerIinOrBin = newValue}
    }
    /// Returns true if `customerIinOrBin` has been explicitly set.
    var hasCustomerIinOrBin: Bool {return self._customerIinOrBin != nil}
    /// Clears the value of `customerIinOrBin`. Subsequent reads from it will return its default value.
    mutating func clearCustomerIinOrBin() {self._customerIinOrBin = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _customerEmail: String? = nil
    fileprivate var _customerPhone: String? = nil
    fileprivate var _customerIinOrBin: String? = nil
  }

  struct Payment: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var type: Kkm_Proto_PaymentTypeEnum {
      get {return _type ?? .paymentCash}
      set {_type = newValue}
    }
    /// Returns true if `type` has been explicitly set.
    var hasType: Bool {return self._type != nil}
    /// Clears the value of `type`. Subsequent reads from it will return its default value.
    mutating func clearType() {self._type = nil}

    var sum: Kkm_Proto_Money {
      get {return _sum ?? Kkm_Proto_Money()}
      set {_sum = newValue}
    }
    /// Returns true if `sum` has been explicitly set.
    var hasSum: Bool {return self._sum != nil}
    /// Clears the value of `sum`. Subsequent reads from it will return its default value.
    mutating func clearSum() {self._sum = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _type: Kkm_Proto_PaymentTypeEnum? = nil
    fileprivate var _sum: Kkm_Proto_Money? = nil
  }

  struct Amounts: Sendable {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var total: Kkm_Proto_Money {
      get {return _total ?? Kkm_Proto_Money()}
      set {_total = newValue}
    }
    /// Returns true if `total` has been explicitly set.
    var hasTotal: Bool {return self._total != nil}
    /// Clears the value of `total`. Subsequent reads from it will return its default value.
    mutating func clearTotal() {self._total = nil}

    var taken: Kkm_Proto_Money {
      get {return _taken ?? Kkm_Proto_Money()}
      set {_taken = newValue}
    }
    /// Returns true if `taken` has been explicitly set.
    var hasTaken: Bool {return self._taken != nil}
    /// Clears the value of `taken`. Subsequent reads from it will return its default value.
    mutating func clearTaken() {self._taken = nil}

    var change: Kkm_Proto_Money {
      get {return _change ?? Kkm_Proto_Money()}
      set {_change = newValue}
    }
    /// Returns true if `change` has been explicitly set.
    var hasChange: Bool {return self._change != nil}
    /// Clears the value of `change`. Subsequent reads from it will return its default value.
    mutating func clearChange() {self._change = nil}

    /// if set discount should't be set
    var markup: Kkm_Proto_TicketRequest.Modifier {
      get {return _markup ?? Kkm_Proto_TicketRequest.Modifier()}
      set {_markup = newValue}
    }
    /// Returns true if `markup` has been explicitly set.
    var hasMarkup: Bool {return self._markup != nil}
    /// Clears the value of `markup`. Subsequent reads from it will return its default value.
    mutating func clearMarkup() {self._markup = nil}

    /// if set markup should't be set
    var discount: Kkm_Proto_TicketRequest.Modifier {
      get {return _discount ?? Kkm_Proto_TicketRequest.Modifier()}
      set {_discount = newValue}
    }
    /// Returns true if `discount` has been explicitly set.
    var hasDiscount: Bool {return self._discount != nil}
    /// Clears the value of `discount`. Subsequent reads from it will return its default value.
    mutating func clearDiscount() {self._discount = nil}

    var unknownFields = SwiftProtobuf.UnknownStorage()

    init() {}

    fileprivate var _total: Kkm_Proto_Money? = nil
    fileprivate var _taken: Kkm_Proto_Money? = nil
    fileprivate var _change: Kkm_Proto_Money? = nil
    fileprivate var _markup: Kkm_Proto_TicketRequest.Modifier? = nil
    fileprivate var _discount: Kkm_Proto_TicketRequest.Modifier? = nil
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

struct Kkm_Proto_TicketResponse: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var ticketNumber: String {
    get {return _ticketNumber ?? String()}
    set {_ticketNumber = newValue}
  }
  /// Returns true if `ticketNumber` has been explicitly set.
  var hasTicketNumber: Bool {return self._ticketNumber != nil}
  /// Clears the value of `ticketNumber`. Subsequent reads from it will return its default value.
  mutating func clearTicketNumber() {self._ticketNumber = nil}

  var qrCode: Data {
    get {return _qrCode ?? Data()}
    set {_qrCode = newValue}
  }
  /// Returns true if `qrCode` has been explicitly set.
  var hasQrCode: Bool {return self._qrCode != nil}
  /// Clears the value of `qrCode`. Subsequent reads from it will return its default value.
  mutating func clearQrCode() {self._qrCode = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _ticketNumber: String? = nil
  fileprivate var _qrCode: Data? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "kkm.proto"

extension Kkm_Proto_TicketRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TicketRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "operation"),
    2: .standard(proto: "date_time"),
    3: .same(proto: "operator"),
    4: .same(proto: "domain"),
    5: .same(proto: "items"),
    6: .same(proto: "payments"),
    7: .same(proto: "taxes"),
    8: .same(proto: "amounts"),
    9: .standard(proto: "extension_options"),
    10: .standard(proto: "offline_ticket_number"),
    11: .standard(proto: "printed_document_number_old"),
    12: .standard(proto: "printed_ticket"),
    13: .standard(proto: "ad_infos"),
    14: .standard(proto: "fr_shift_number"),
    15: .standard(proto: "shift_document_number"),
    16: .standard(proto: "printed_document_number"),
  ]

  fileprivate class _StorageClass {
    var _operation: Kkm_Proto_OperationTypeEnum? = nil
    var _dateTime: Kkm_Proto_DateTime? = nil
    var _operator: Kkm_Proto_Operator? = nil
    var _domain: Kkm_Proto_TicketRequest.Domain? = nil
    var _items: [Kkm_Proto_TicketRequest.Item] = []
    var _payments: [Kkm_Proto_TicketRequest.Payment] = []
    var _taxes: [Kkm_Proto_TicketRequest.Tax] = []
    var _amounts: Kkm_Proto_TicketRequest.Amounts? = nil
    var _extensionOptions: Kkm_Proto_TicketRequest.ExtensionOptions? = nil
    var _offlineTicketNumber: UInt32? = nil
    var _printedDocumentNumberOld: String? = nil
    var _printedTicket: String? = nil
    var _adInfos: [Kkm_Proto_TicketAdInfo] = []
    var _frShiftNumber: UInt32? = nil
    var _shiftDocumentNumber: UInt32? = nil
    var _printedDocumentNumber: UInt64? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _operation = source._operation
      _dateTime = source._dateTime
      _operator = source._operator
      _domain = source._domain
      _items = source._items
      _payments = source._payments
      _taxes = source._taxes
      _amounts = source._amounts
      _extensionOptions = source._extensionOptions
      _offlineTicketNumber = source._offlineTicketNumber
      _printedDocumentNumberOld = source._printedDocumentNumberOld
      _printedTicket = source._printedTicket
      _adInfos = source._adInfos
      _frShiftNumber = source._frShiftNumber
      _shiftDocumentNumber = source._shiftDocumentNumber
      _printedDocumentNumber = source._printedDocumentNumber
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._operation == nil {return false}
      if _storage._dateTime == nil {return false}
      if _storage._operator == nil {return false}
      if _storage._amounts == nil {return false}
      if let v = _storage._dateTime, !v.isInitialized {return false}
      if let v = _storage._operator, !v.isInitialized {return false}
      if let v = _storage._domain, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._items) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._payments) {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._taxes) {return false}
      if let v = _storage._amounts, !v.isInitialized {return false}
      if let v = _storage._extensionOptions, !v.isInitialized {return false}
      if !SwiftProtobuf.Internal.areAllInitialized(_storage._adInfos) {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._operation) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._dateTime) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._operator) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._domain) }()
        case 5: try { try decoder.decodeRepeatedMessageField(value: &_storage._items) }()
        case 6: try { try decoder.decodeRepeatedMessageField(value: &_storage._payments) }()
        case 7: try { try decoder.decodeRepeatedMessageField(value: &_storage._taxes) }()
        case 8: try { try decoder.decodeSingularMessageField(value: &_storage._amounts) }()
        case 9: try { try decoder.decodeSingularMessageField(value: &_storage._extensionOptions) }()
        case 10: try { try decoder.decodeSingularUInt32Field(value: &_storage._offlineTicketNumber) }()
        case 11: try { try decoder.decodeSingularStringField(value: &_storage._printedDocumentNumberOld) }()
        case 12: try { try decoder.decodeSingularStringField(value: &_storage._printedTicket) }()
        case 13: try { try decoder.decodeRepeatedMessageField(value: &_storage._adInfos) }()
        case 14: try { try decoder.decodeSingularUInt32Field(value: &_storage._frShiftNumber) }()
        case 15: try { try decoder.decodeSingularUInt32Field(value: &_storage._shiftDocumentNumber) }()
        case 16: try { try decoder.decodeSingularUInt64Field(value: &_storage._printedDocumentNumber) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._operation {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._dateTime {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._operator {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._domain {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      if !_storage._items.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._items, fieldNumber: 5)
      }
      if !_storage._payments.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._payments, fieldNumber: 6)
      }
      if !_storage._taxes.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._taxes, fieldNumber: 7)
      }
      try { if let v = _storage._amounts {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 8)
      } }()
      try { if let v = _storage._extensionOptions {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 9)
      } }()
      try { if let v = _storage._offlineTicketNumber {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 10)
      } }()
      try { if let v = _storage._printedDocumentNumberOld {
        try visitor.visitSingularStringField(value: v, fieldNumber: 11)
      } }()
      try { if let v = _storage._printedTicket {
        try visitor.visitSingularStringField(value: v, fieldNumber: 12)
      } }()
      if !_storage._adInfos.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._adInfos, fieldNumber: 13)
      }
      try { if let v = _storage._frShiftNumber {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 14)
      } }()
      try { if let v = _storage._shiftDocumentNumber {
        try visitor.visitSingularUInt32Field(value: v, fieldNumber: 15)
      } }()
      try { if let v = _storage._printedDocumentNumber {
        try visitor.visitSingularUInt64Field(value: v, fieldNumber: 16)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kkm_Proto_TicketRequest, rhs: Kkm_Proto_TicketRequest) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._operation != rhs_storage._operation {return false}
        if _storage._dateTime != rhs_storage._dateTime {return false}
        if _storage._operator != rhs_storage._operator {return false}
        if _storage._domain != rhs_storage._domain {return false}
        if _storage._items != rhs_storage._items {return false}
        if _storage._payments != rhs_storage._payments {return false}
        if _storage._taxes != rhs_storage._taxes {return false}
        if _storage._amounts != rhs_storage._amounts {return false}
        if _storage._extensionOptions != rhs_storage._extensionOptions {return false}
        if _storage._offlineTicketNumber != rhs_storage._offlineTicketNumber {return false}
        if _storage._printedDocumentNumberOld != rhs_storage._printedDocumentNumberOld {return false}
        if _storage._printedTicket != rhs_storage._printedTicket {return false}
        if _storage._adInfos != rhs_storage._adInfos {return false}
        if _storage._frShiftNumber != rhs_storage._frShiftNumber {return false}
        if _storage._shiftDocumentNumber != rhs_storage._shiftDocumentNumber {return false}
        if _storage._printedDocumentNumber != rhs_storage._printedDocumentNumber {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kkm_Proto_TicketRequest.Tax: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Kkm_Proto_TicketRequest.protoMessageName + ".Tax"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "tax_type"),
    2: .standard(proto: "taxation_type"),
    3: .same(proto: "percent"),
    4: .same(proto: "sum"),
    5: .standard(proto: "is_in_total_sum"),
  ]

  public var isInitialized: Bool {
    if self._taxType == nil {return false}
    if self._percent == nil {return false}
    if self._sum == nil {return false}
    if self._isInTotalSum == nil {return false}
    if let v = self._sum, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._taxType) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._taxationType) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._percent) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._sum) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self._isInTotalSum) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._taxType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._taxationType {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._percent {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._sum {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._isInTotalSum {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kkm_Proto_TicketRequest.Tax, rhs: Kkm_Proto_TicketRequest.Tax) -> Bool {
    if lhs._taxType != rhs._taxType {return false}
    if lhs._taxationType != rhs._taxationType {return false}
    if lhs._percent != rhs._percent {return false}
    if lhs._sum != rhs._sum {return false}
    if lhs._isInTotalSum != rhs._isInTotalSum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kkm_Proto_TicketRequest.Modifier: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Kkm_Proto_TicketRequest.protoMessageName + ".Modifier"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .same(proto: "sum"),
    3: .same(proto: "taxes"),
    4: .same(proto: "auxiliary"),
  ]

  public var isInitialized: Bool {
    if self._sum == nil {return false}
    if let v = self._sum, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.taxes) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.auxiliary) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sum) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.taxes) }()
      case 4: try { try decoder.decodeRepeatedMessageField(value: &self.auxiliary) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sum {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    if !self.taxes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.taxes, fieldNumber: 3)
    }
    if !self.auxiliary.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.auxiliary, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kkm_Proto_TicketRequest.Modifier, rhs: Kkm_Proto_TicketRequest.Modifier) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._sum != rhs._sum {return false}
    if lhs.taxes != rhs.taxes {return false}
    if lhs.auxiliary != rhs.auxiliary {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kkm_Proto_TicketRequest.Item: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Kkm_Proto_TicketRequest.protoMessageName + ".Item"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "commodity"),
    3: .standard(proto: "storno_commodity"),
    4: .same(proto: "markup"),
    5: .standard(proto: "storno_markup"),
    6: .same(proto: "discount"),
    7: .standard(proto: "storno_discount"),
  ]

  fileprivate class _StorageClass {
    var _type: Kkm_Proto_TicketRequest.Item.ItemTypeEnum? = nil
    var _commodity: Kkm_Proto_TicketRequest.Item.Commodity? = nil
    var _stornoCommodity: Kkm_Proto_TicketRequest.Item.StornoCommodity? = nil
    var _markup: Kkm_Proto_TicketRequest.Modifier? = nil
    var _stornoMarkup: Kkm_Proto_TicketRequest.Modifier? = nil
    var _discount: Kkm_Proto_TicketRequest.Modifier? = nil
    var _stornoDiscount: Kkm_Proto_TicketRequest.Modifier? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _commodity = source._commodity
      _stornoCommodity = source._stornoCommodity
      _markup = source._markup
      _stornoMarkup = source._stornoMarkup
      _discount = source._discount
      _stornoDiscount = source._stornoDiscount
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._type == nil {return false}
      if let v = _storage._commodity, !v.isInitialized {return false}
      if let v = _storage._stornoCommodity, !v.isInitialized {return false}
      if let v = _storage._markup, !v.isInitialized {return false}
      if let v = _storage._stornoMarkup, !v.isInitialized {return false}
      if let v = _storage._discount, !v.isInitialized {return false}
      if let v = _storage._stornoDiscount, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._commodity) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._stornoCommodity) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._markup) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._stornoMarkup) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._discount) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._stornoDiscount) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._type {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._commodity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._stornoCommodity {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._markup {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._stornoMarkup {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._discount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._stornoDiscount {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kkm_Proto_TicketRequest.Item, rhs: Kkm_Proto_TicketRequest.Item) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._commodity != rhs_storage._commodity {return false}
        if _storage._stornoCommodity != rhs_storage._stornoCommodity {return false}
        if _storage._markup != rhs_storage._markup {return false}
        if _storage._stornoMarkup != rhs_storage._stornoMarkup {return false}
        if _storage._discount != rhs_storage._discount {return false}
        if _storage._stornoDiscount != rhs_storage._stornoDiscount {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kkm_Proto_TicketRequest.Item.ItemTypeEnum: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ITEM_TYPE_COMMODITY"),
    2: .same(proto: "ITEM_TYPE_STORNO_COMMODITY"),
    3: .same(proto: "ITEM_TYPE_MARKUP"),
    4: .same(proto: "ITEM_TYPE_STORNO_MARKUP"),
    5: .same(proto: "ITEM_TYPE_DISCOUNT"),
    6: .same(proto: "ITEM_TYPE_STORNO_DISCOUNT"),
  ]
}

extension Kkm_Proto_TicketRequest.Item.Commodity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Kkm_Proto_TicketRequest.Item.protoMessageName + ".Commodity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "code"),
    2: .same(proto: "name"),
    3: .standard(proto: "section_code"),
    4: .same(proto: "quantity"),
    5: .same(proto: "price"),
    6: .same(proto: "sum"),
    7: .same(proto: "taxes"),
    8: .standard(proto: "excise_stamp"),
    9: .same(proto: "auxiliary"),
    10: .standard(proto: "physical_label"),
    11: .standard(proto: "product_id"),
    12: .same(proto: "barcode"),
    13: .standard(proto: "measure_unit_code"),
  ]

  public var isInitialized: Bool {
    if self._sectionCode == nil {return false}
    if self._quantity == nil {return false}
    if self._price == nil {return false}
    if self._sum == nil {return false}
    if let v = self._price, !v.isInitialized {return false}
    if let v = self._sum, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.taxes) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.auxiliary) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt64Field(value: &self._code) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._sectionCode) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._quantity) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._price) }()
      case 6: try { try decoder.decodeSingularMessageField(value: &self._sum) }()
      case 7: try { try decoder.decodeRepeatedMessageField(value: &self.taxes) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self._exciseStamp) }()
      case 9: try { try decoder.decodeRepeatedMessageField(value: &self.auxiliary) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self._physicalLabel) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self._productID) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self._barcode) }()
      case 13: try { try decoder.decodeSingularStringField(value: &self._measureUnitCode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._code {
      try visitor.visitSingularUInt64Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._sectionCode {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._quantity {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._price {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try { if let v = self._sum {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
    } }()
    if !self.taxes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.taxes, fieldNumber: 7)
    }
    try { if let v = self._exciseStamp {
      try visitor.visitSingularStringField(value: v, fieldNumber: 8)
    } }()
    if !self.auxiliary.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.auxiliary, fieldNumber: 9)
    }
    try { if let v = self._physicalLabel {
      try visitor.visitSingularStringField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._productID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._barcode {
      try visitor.visitSingularStringField(value: v, fieldNumber: 12)
    } }()
    try { if let v = self._measureUnitCode {
      try visitor.visitSingularStringField(value: v, fieldNumber: 13)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kkm_Proto_TicketRequest.Item.Commodity, rhs: Kkm_Proto_TicketRequest.Item.Commodity) -> Bool {
    if lhs._code != rhs._code {return false}
    if lhs._name != rhs._name {return false}
    if lhs._sectionCode != rhs._sectionCode {return false}
    if lhs._quantity != rhs._quantity {return false}
    if lhs._price != rhs._price {return false}
    if lhs._sum != rhs._sum {return false}
    if lhs.taxes != rhs.taxes {return false}
    if lhs._exciseStamp != rhs._exciseStamp {return false}
    if lhs.auxiliary != rhs.auxiliary {return false}
    if lhs._physicalLabel != rhs._physicalLabel {return false}
    if lhs._productID != rhs._productID {return false}
    if lhs._barcode != rhs._barcode {return false}
    if lhs._measureUnitCode != rhs._measureUnitCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kkm_Proto_TicketRequest.Item.StornoCommodity: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Kkm_Proto_TicketRequest.Item.protoMessageName + ".StornoCommodity"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "name"),
    2: .standard(proto: "section_code"),
    3: .same(proto: "quantity"),
    4: .same(proto: "price"),
    5: .same(proto: "sum"),
    6: .same(proto: "taxes"),
    7: .standard(proto: "excise_stamp"),
    8: .same(proto: "auxiliary"),
    9: .standard(proto: "physical_label"),
    10: .standard(proto: "product_id"),
    11: .same(proto: "barcode"),
    12: .standard(proto: "measure_unit_code"),
  ]

  public var isInitialized: Bool {
    if self._sectionCode == nil {return false}
    if self._quantity == nil {return false}
    if self._price == nil {return false}
    if self._sum == nil {return false}
    if let v = self._price, !v.isInitialized {return false}
    if let v = self._sum, !v.isInitialized {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.taxes) {return false}
    if !SwiftProtobuf.Internal.areAllInitialized(self.auxiliary) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._name) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._sectionCode) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._quantity) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._price) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._sum) }()
      case 6: try { try decoder.decodeRepeatedMessageField(value: &self.taxes) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self._exciseStamp) }()
      case 8: try { try decoder.decodeRepeatedMessageField(value: &self.auxiliary) }()
      case 9: try { try decoder.decodeSingularStringField(value: &self._physicalLabel) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self._productID) }()
      case 11: try { try decoder.decodeSingularStringField(value: &self._barcode) }()
      case 12: try { try decoder.decodeSingularStringField(value: &self._measureUnitCode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._name {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sectionCode {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._quantity {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._price {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._sum {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    if !self.taxes.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.taxes, fieldNumber: 6)
    }
    try { if let v = self._exciseStamp {
      try visitor.visitSingularStringField(value: v, fieldNumber: 7)
    } }()
    if !self.auxiliary.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.auxiliary, fieldNumber: 8)
    }
    try { if let v = self._physicalLabel {
      try visitor.visitSingularStringField(value: v, fieldNumber: 9)
    } }()
    try { if let v = self._productID {
      try visitor.visitSingularStringField(value: v, fieldNumber: 10)
    } }()
    try { if let v = self._barcode {
      try visitor.visitSingularStringField(value: v, fieldNumber: 11)
    } }()
    try { if let v = self._measureUnitCode {
      try visitor.visitSingularStringField(value: v, fieldNumber: 12)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kkm_Proto_TicketRequest.Item.StornoCommodity, rhs: Kkm_Proto_TicketRequest.Item.StornoCommodity) -> Bool {
    if lhs._name != rhs._name {return false}
    if lhs._sectionCode != rhs._sectionCode {return false}
    if lhs._quantity != rhs._quantity {return false}
    if lhs._price != rhs._price {return false}
    if lhs._sum != rhs._sum {return false}
    if lhs.taxes != rhs.taxes {return false}
    if lhs._exciseStamp != rhs._exciseStamp {return false}
    if lhs.auxiliary != rhs.auxiliary {return false}
    if lhs._physicalLabel != rhs._physicalLabel {return false}
    if lhs._productID != rhs._productID {return false}
    if lhs._barcode != rhs._barcode {return false}
    if lhs._measureUnitCode != rhs._measureUnitCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kkm_Proto_TicketRequest.Domain: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Kkm_Proto_TicketRequest.protoMessageName + ".Domain"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "services"),
    3: .same(proto: "gasoil"),
    4: .same(proto: "taxi"),
    5: .same(proto: "parking"),
  ]

  fileprivate class _StorageClass {
    var _type: Kkm_Proto_DomainTypeEnum? = nil
    var _services: Kkm_Proto_TicketRequest.Domain.Services? = nil
    var _gasoil: Kkm_Proto_TicketRequest.Domain.GasOil? = nil
    var _taxi: Kkm_Proto_TicketRequest.Domain.Taxi? = nil
    var _parking: Kkm_Proto_TicketRequest.Domain.Parking? = nil

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _type = source._type
      _services = source._services
      _gasoil = source._gasoil
      _taxi = source._taxi
      _parking = source._parking
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public var isInitialized: Bool {
    return withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._services, !v.isInitialized {return false}
      if let v = _storage._gasoil, !v.isInitialized {return false}
      if let v = _storage._taxi, !v.isInitialized {return false}
      if let v = _storage._parking, !v.isInitialized {return false}
      return true
    }
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularEnumField(value: &_storage._type) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._services) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._gasoil) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._taxi) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._parking) }()
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._type {
        try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._services {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._gasoil {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._taxi {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._parking {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kkm_Proto_TicketRequest.Domain, rhs: Kkm_Proto_TicketRequest.Domain) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._type != rhs_storage._type {return false}
        if _storage._services != rhs_storage._services {return false}
        if _storage._gasoil != rhs_storage._gasoil {return false}
        if _storage._taxi != rhs_storage._taxi {return false}
        if _storage._parking != rhs_storage._parking {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kkm_Proto_TicketRequest.Domain.Services: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Kkm_Proto_TicketRequest.Domain.protoMessageName + ".Services"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "account_number"),
  ]

  public var isInitialized: Bool {
    if self._accountNumber == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._accountNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._accountNumber {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kkm_Proto_TicketRequest.Domain.Services, rhs: Kkm_Proto_TicketRequest.Domain.Services) -> Bool {
    if lhs._accountNumber != rhs._accountNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kkm_Proto_TicketRequest.Domain.GasOil: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Kkm_Proto_TicketRequest.Domain.protoMessageName + ".GasOil"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "correction_number"),
    2: .standard(proto: "correction_sum"),
    3: .standard(proto: "card_number"),
  ]

  public var isInitialized: Bool {
    if let v = self._correctionSum, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._correctionNumber) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._correctionSum) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._cardNumber) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._correctionNumber {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._correctionSum {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._cardNumber {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kkm_Proto_TicketRequest.Domain.GasOil, rhs: Kkm_Proto_TicketRequest.Domain.GasOil) -> Bool {
    if lhs._correctionNumber != rhs._correctionNumber {return false}
    if lhs._correctionSum != rhs._correctionSum {return false}
    if lhs._cardNumber != rhs._cardNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kkm_Proto_TicketRequest.Domain.Taxi: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Kkm_Proto_TicketRequest.Domain.protoMessageName + ".Taxi"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "car_number"),
    2: .standard(proto: "is_order"),
    3: .standard(proto: "current_fee"),
  ]

  public var isInitialized: Bool {
    if self._carNumber == nil {return false}
    if self._isOrder == nil {return false}
    if self._currentFee == nil {return false}
    if let v = self._currentFee, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._carNumber) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self._isOrder) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._currentFee) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._carNumber {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._isOrder {
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._currentFee {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kkm_Proto_TicketRequest.Domain.Taxi, rhs: Kkm_Proto_TicketRequest.Domain.Taxi) -> Bool {
    if lhs._carNumber != rhs._carNumber {return false}
    if lhs._isOrder != rhs._isOrder {return false}
    if lhs._currentFee != rhs._currentFee {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kkm_Proto_TicketRequest.Domain.Parking: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Kkm_Proto_TicketRequest.Domain.protoMessageName + ".Parking"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "begin_time"),
    2: .standard(proto: "end_time"),
  ]

  public var isInitialized: Bool {
    if self._beginTime == nil {return false}
    if self._endTime == nil {return false}
    if let v = self._beginTime, !v.isInitialized {return false}
    if let v = self._endTime, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._beginTime) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._endTime) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._beginTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._endTime {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kkm_Proto_TicketRequest.Domain.Parking, rhs: Kkm_Proto_TicketRequest.Domain.Parking) -> Bool {
    if lhs._beginTime != rhs._beginTime {return false}
    if lhs._endTime != rhs._endTime {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kkm_Proto_TicketRequest.ExtensionOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Kkm_Proto_TicketRequest.protoMessageName + ".ExtensionOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "customer_email"),
    2: .standard(proto: "customer_phone"),
    3: .same(proto: "auxiliary"),
    4: .standard(proto: "customer_iin_or_bin"),
  ]

  public var isInitialized: Bool {
    if !SwiftProtobuf.Internal.areAllInitialized(self.auxiliary) {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._customerEmail) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._customerPhone) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.auxiliary) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._customerIinOrBin) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._customerEmail {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._customerPhone {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if !self.auxiliary.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.auxiliary, fieldNumber: 3)
    }
    try { if let v = self._customerIinOrBin {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kkm_Proto_TicketRequest.ExtensionOptions, rhs: Kkm_Proto_TicketRequest.ExtensionOptions) -> Bool {
    if lhs._customerEmail != rhs._customerEmail {return false}
    if lhs._customerPhone != rhs._customerPhone {return false}
    if lhs.auxiliary != rhs.auxiliary {return false}
    if lhs._customerIinOrBin != rhs._customerIinOrBin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kkm_Proto_TicketRequest.Payment: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Kkm_Proto_TicketRequest.protoMessageName + ".Payment"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "sum"),
  ]

  public var isInitialized: Bool {
    if self._type == nil {return false}
    if self._sum == nil {return false}
    if let v = self._sum, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._sum) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._type {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._sum {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kkm_Proto_TicketRequest.Payment, rhs: Kkm_Proto_TicketRequest.Payment) -> Bool {
    if lhs._type != rhs._type {return false}
    if lhs._sum != rhs._sum {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kkm_Proto_TicketRequest.Amounts: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = Kkm_Proto_TicketRequest.protoMessageName + ".Amounts"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "total"),
    2: .same(proto: "taken"),
    3: .same(proto: "change"),
    4: .same(proto: "markup"),
    5: .same(proto: "discount"),
  ]

  public var isInitialized: Bool {
    if self._total == nil {return false}
    if let v = self._total, !v.isInitialized {return false}
    if let v = self._taken, !v.isInitialized {return false}
    if let v = self._change, !v.isInitialized {return false}
    if let v = self._markup, !v.isInitialized {return false}
    if let v = self._discount, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._total) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._taken) }()
      case 3: try { try decoder.decodeSingularMessageField(value: &self._change) }()
      case 4: try { try decoder.decodeSingularMessageField(value: &self._markup) }()
      case 5: try { try decoder.decodeSingularMessageField(value: &self._discount) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._total {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._taken {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._change {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._markup {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
    } }()
    try { if let v = self._discount {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kkm_Proto_TicketRequest.Amounts, rhs: Kkm_Proto_TicketRequest.Amounts) -> Bool {
    if lhs._total != rhs._total {return false}
    if lhs._taken != rhs._taken {return false}
    if lhs._change != rhs._change {return false}
    if lhs._markup != rhs._markup {return false}
    if lhs._discount != rhs._discount {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kkm_Proto_TicketResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".TicketResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "ticket_number"),
    2: .standard(proto: "qr_code"),
  ]

  public var isInitialized: Bool {
    if self._ticketNumber == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self._ticketNumber) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self._qrCode) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._ticketNumber {
      try visitor.visitSingularStringField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._qrCode {
      try visitor.visitSingularBytesField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kkm_Proto_TicketResponse, rhs: Kkm_Proto_TicketResponse) -> Bool {
    if lhs._ticketNumber != rhs._ticketNumber {return false}
    if lhs._qrCode != rhs._qrCode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
