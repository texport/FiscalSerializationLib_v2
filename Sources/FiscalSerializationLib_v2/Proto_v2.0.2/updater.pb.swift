// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: updater.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

enum Kkm_FdSvc_Proto_UpdateType: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case nothing // = 1
  case update // = 2
  case rollback // = 3

  init() {
    self = .nothing
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 1: self = .nothing
    case 2: self = .update
    case 3: self = .rollback
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .nothing: return 1
    case .update: return 2
    case .rollback: return 3
    }
  }

}

enum Kkm_FdSvc_Proto_UpdateStage: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int

  /// just in case 
  case idle // = 0
  case infoRequested // = 1
  case infoReceived // = 2
  case downloading // = 3
  case readyToInstall // = 4
  case extracting // = 5
  case installing // = 6
  case updatesInstalled // = 7
  case rollbackScheduled // = 100
  case rollingBack // = 101
  case rollbackDone // = 102
  case failed // = 250

  init() {
    self = .idle
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .idle
    case 1: self = .infoRequested
    case 2: self = .infoReceived
    case 3: self = .downloading
    case 4: self = .readyToInstall
    case 5: self = .extracting
    case 6: self = .installing
    case 7: self = .updatesInstalled
    case 100: self = .rollbackScheduled
    case 101: self = .rollingBack
    case 102: self = .rollbackDone
    case 250: self = .failed
    default: return nil
    }
  }

  var rawValue: Int {
    switch self {
    case .idle: return 0
    case .infoRequested: return 1
    case .infoReceived: return 2
    case .downloading: return 3
    case .readyToInstall: return 4
    case .extracting: return 5
    case .installing: return 6
    case .updatesInstalled: return 7
    case .rollbackScheduled: return 100
    case .rollingBack: return 101
    case .rollbackDone: return 102
    case .failed: return 250
    }
  }

}

struct Kkm_FdSvc_Proto_VersionInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var major: UInt32 {
    get {return _major ?? 0}
    set {_major = newValue}
  }
  /// Returns true if `major` has been explicitly set.
  var hasMajor: Bool {return self._major != nil}
  /// Clears the value of `major`. Subsequent reads from it will return its default value.
  mutating func clearMajor() {self._major = nil}

  var minor: UInt32 {
    get {return _minor ?? 0}
    set {_minor = newValue}
  }
  /// Returns true if `minor` has been explicitly set.
  var hasMinor: Bool {return self._minor != nil}
  /// Clears the value of `minor`. Subsequent reads from it will return its default value.
  mutating func clearMinor() {self._minor = nil}

  var build: UInt32 {
    get {return _build ?? 0}
    set {_build = newValue}
  }
  /// Returns true if `build` has been explicitly set.
  var hasBuild: Bool {return self._build != nil}
  /// Clears the value of `build`. Subsequent reads from it will return its default value.
  mutating func clearBuild() {self._build = nil}

  var revision: UInt32 {
    get {return _revision ?? 0}
    set {_revision = newValue}
  }
  /// Returns true if `revision` has been explicitly set.
  var hasRevision: Bool {return self._revision != nil}
  /// Clears the value of `revision`. Subsequent reads from it will return its default value.
  mutating func clearRevision() {self._revision = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _major: UInt32? = nil
  fileprivate var _minor: UInt32? = nil
  fileprivate var _build: UInt32? = nil
  fileprivate var _revision: UInt32? = nil
}

struct Kkm_FdSvc_Proto_UpdateStatusInfo: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var updateType: Kkm_FdSvc_Proto_UpdateType {
    get {return _updateType ?? .nothing}
    set {_updateType = newValue}
  }
  /// Returns true if `updateType` has been explicitly set.
  var hasUpdateType: Bool {return self._updateType != nil}
  /// Clears the value of `updateType`. Subsequent reads from it will return its default value.
  mutating func clearUpdateType() {self._updateType = nil}

  var targetVersion: Kkm_FdSvc_Proto_VersionInfo {
    get {return _targetVersion ?? Kkm_FdSvc_Proto_VersionInfo()}
    set {_targetVersion = newValue}
  }
  /// Returns true if `targetVersion` has been explicitly set.
  var hasTargetVersion: Bool {return self._targetVersion != nil}
  /// Clears the value of `targetVersion`. Subsequent reads from it will return its default value.
  mutating func clearTargetVersion() {self._targetVersion = nil}

  var updateStage: Kkm_FdSvc_Proto_UpdateStage {
    get {return _updateStage ?? .idle}
    set {_updateStage = newValue}
  }
  /// Returns true if `updateStage` has been explicitly set.
  var hasUpdateStage: Bool {return self._updateStage != nil}
  /// Clears the value of `updateStage`. Subsequent reads from it will return its default value.
  mutating func clearUpdateStage() {self._updateStage = nil}

  var errorMsg: String {
    get {return _errorMsg ?? String()}
    set {_errorMsg = newValue}
  }
  /// Returns true if `errorMsg` has been explicitly set.
  var hasErrorMsg: Bool {return self._errorMsg != nil}
  /// Clears the value of `errorMsg`. Subsequent reads from it will return its default value.
  mutating func clearErrorMsg() {self._errorMsg = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _updateType: Kkm_FdSvc_Proto_UpdateType? = nil
  fileprivate var _targetVersion: Kkm_FdSvc_Proto_VersionInfo? = nil
  fileprivate var _updateStage: Kkm_FdSvc_Proto_UpdateStage? = nil
  fileprivate var _errorMsg: String? = nil
}

struct Kkm_FdSvc_Proto_UpdateAction: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var updateType: Kkm_FdSvc_Proto_UpdateType {
    get {return _updateType ?? .nothing}
    set {_updateType = newValue}
  }
  /// Returns true if `updateType` has been explicitly set.
  var hasUpdateType: Bool {return self._updateType != nil}
  /// Clears the value of `updateType`. Subsequent reads from it will return its default value.
  mutating func clearUpdateType() {self._updateType = nil}

  /// required if update_type != UPDATE_TYPE_NOTHING 
  var requiredVersion: Kkm_FdSvc_Proto_VersionInfo {
    get {return _requiredVersion ?? Kkm_FdSvc_Proto_VersionInfo()}
    set {_requiredVersion = newValue}
  }
  /// Returns true if `requiredVersion` has been explicitly set.
  var hasRequiredVersion: Bool {return self._requiredVersion != nil}
  /// Clears the value of `requiredVersion`. Subsequent reads from it will return its default value.
  mutating func clearRequiredVersion() {self._requiredVersion = nil}

  var downloadURL: String {
    get {return _downloadURL ?? String()}
    set {_downloadURL = newValue}
  }
  /// Returns true if `downloadURL` has been explicitly set.
  var hasDownloadURL: Bool {return self._downloadURL != nil}
  /// Clears the value of `downloadURL`. Subsequent reads from it will return its default value.
  mutating func clearDownloadURL() {self._downloadURL = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _updateType: Kkm_FdSvc_Proto_UpdateType? = nil
  fileprivate var _requiredVersion: Kkm_FdSvc_Proto_VersionInfo? = nil
  fileprivate var _downloadURL: String? = nil
}

struct Kkm_FdSvc_Proto_CheckUpdatesRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var installedVersion: Kkm_FdSvc_Proto_VersionInfo {
    get {return _installedVersion ?? Kkm_FdSvc_Proto_VersionInfo()}
    set {_installedVersion = newValue}
  }
  /// Returns true if `installedVersion` has been explicitly set.
  var hasInstalledVersion: Bool {return self._installedVersion != nil}
  /// Clears the value of `installedVersion`. Subsequent reads from it will return its default value.
  mutating func clearInstalledVersion() {self._installedVersion = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _installedVersion: Kkm_FdSvc_Proto_VersionInfo? = nil
}

struct Kkm_FdSvc_Proto_PostUpdateStatusRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var info: Kkm_FdSvc_Proto_UpdateStatusInfo {
    get {return _info ?? Kkm_FdSvc_Proto_UpdateStatusInfo()}
    set {_info = newValue}
  }
  /// Returns true if `info` has been explicitly set.
  var hasInfo: Bool {return self._info != nil}
  /// Clears the value of `info`. Subsequent reads from it will return its default value.
  mutating func clearInfo() {self._info = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _info: Kkm_FdSvc_Proto_UpdateStatusInfo? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "kkm.fd_svc.proto"

extension Kkm_FdSvc_Proto_UpdateType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "UPDATE_TYPE_NOTHING"),
    2: .same(proto: "UPDATE_TYPE_UPDATE"),
    3: .same(proto: "UPDATE_TYPE_ROLLBACK"),
  ]
}

extension Kkm_FdSvc_Proto_UpdateStage: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "UPDATE_STAGE_IDLE"),
    1: .same(proto: "UPDATE_STAGE_INFO_REQUESTED"),
    2: .same(proto: "UPDATE_STAGE_INFO_RECEIVED"),
    3: .same(proto: "UPDATE_STAGE_DOWNLOADING"),
    4: .same(proto: "UPDATE_STAGE_READY_TO_INSTALL"),
    5: .same(proto: "UPDATE_STAGE_EXTRACTING"),
    6: .same(proto: "UPDATE_STAGE_INSTALLING"),
    7: .same(proto: "UPDATE_STAGE_UPDATES_INSTALLED"),
    100: .same(proto: "UPDATE_STAGE_ROLLBACK_SCHEDULED"),
    101: .same(proto: "UPDATE_STAGE_ROLLING_BACK"),
    102: .same(proto: "UPDATE_STAGE_ROLLBACK_DONE"),
    250: .same(proto: "UPDATE_STAGE_FAILED"),
  ]
}

extension Kkm_FdSvc_Proto_VersionInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".VersionInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "major"),
    2: .same(proto: "minor"),
    3: .same(proto: "build"),
    4: .same(proto: "revision"),
  ]

  public var isInitialized: Bool {
    if self._major == nil {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self._major) }()
      case 2: try { try decoder.decodeSingularUInt32Field(value: &self._minor) }()
      case 3: try { try decoder.decodeSingularUInt32Field(value: &self._build) }()
      case 4: try { try decoder.decodeSingularUInt32Field(value: &self._revision) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._major {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._minor {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._build {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._revision {
      try visitor.visitSingularUInt32Field(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kkm_FdSvc_Proto_VersionInfo, rhs: Kkm_FdSvc_Proto_VersionInfo) -> Bool {
    if lhs._major != rhs._major {return false}
    if lhs._minor != rhs._minor {return false}
    if lhs._build != rhs._build {return false}
    if lhs._revision != rhs._revision {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kkm_FdSvc_Proto_UpdateStatusInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateStatusInfo"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "update_type"),
    2: .standard(proto: "target_version"),
    3: .standard(proto: "update_stage"),
    4: .standard(proto: "error_msg"),
  ]

  public var isInitialized: Bool {
    if self._updateType == nil {return false}
    if self._updateStage == nil {return false}
    if let v = self._targetVersion, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._updateType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._targetVersion) }()
      case 3: try { try decoder.decodeSingularEnumField(value: &self._updateStage) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self._errorMsg) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._updateType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._targetVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._updateStage {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 3)
    } }()
    try { if let v = self._errorMsg {
      try visitor.visitSingularStringField(value: v, fieldNumber: 4)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kkm_FdSvc_Proto_UpdateStatusInfo, rhs: Kkm_FdSvc_Proto_UpdateStatusInfo) -> Bool {
    if lhs._updateType != rhs._updateType {return false}
    if lhs._targetVersion != rhs._targetVersion {return false}
    if lhs._updateStage != rhs._updateStage {return false}
    if lhs._errorMsg != rhs._errorMsg {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kkm_FdSvc_Proto_UpdateAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UpdateAction"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "update_type"),
    2: .standard(proto: "required_version"),
    3: .standard(proto: "download_url"),
  ]

  public var isInitialized: Bool {
    if self._updateType == nil {return false}
    if let v = self._requiredVersion, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self._updateType) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._requiredVersion) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self._downloadURL) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._updateType {
      try visitor.visitSingularEnumField(value: v, fieldNumber: 1)
    } }()
    try { if let v = self._requiredVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try { if let v = self._downloadURL {
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kkm_FdSvc_Proto_UpdateAction, rhs: Kkm_FdSvc_Proto_UpdateAction) -> Bool {
    if lhs._updateType != rhs._updateType {return false}
    if lhs._requiredVersion != rhs._requiredVersion {return false}
    if lhs._downloadURL != rhs._downloadURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kkm_FdSvc_Proto_CheckUpdatesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".CheckUpdatesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "installed_version"),
  ]

  public var isInitialized: Bool {
    if self._installedVersion == nil {return false}
    if let v = self._installedVersion, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._installedVersion) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._installedVersion {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kkm_FdSvc_Proto_CheckUpdatesRequest, rhs: Kkm_FdSvc_Proto_CheckUpdatesRequest) -> Bool {
    if lhs._installedVersion != rhs._installedVersion {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Kkm_FdSvc_Proto_PostUpdateStatusRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PostUpdateStatusRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "info"),
  ]

  public var isInitialized: Bool {
    if self._info == nil {return false}
    if let v = self._info, !v.isInitialized {return false}
    return true
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._info) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._info {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Kkm_FdSvc_Proto_PostUpdateStatusRequest, rhs: Kkm_FdSvc_Proto_PostUpdateStatusRequest) -> Bool {
    if lhs._info != rhs._info {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
